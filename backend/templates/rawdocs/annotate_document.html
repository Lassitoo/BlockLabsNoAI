{#template/annotate_document.html#}
{% extends "base.html" %}
{% load rawdocs_extras %}
{% load static %}
{% block title %}Annotation {{ document.file.name|basename }}  RawDocs{% endblock %}

{% block content %}
<link rel="stylesheet" href="{% static 'rawdocs/css/rlhf_styles.css' %}">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

<script type="text/javascript">

// Generate distinct colors for annotation types
const typeColors = {};

function generateDistinctColor(existingColors = []) {
    const hues = [0, 30, 60, 120, 180, 210, 240, 270, 300, 330]; // Distinct hues
    const saturations = [70, 85, 100];
    const lightnesses = [45, 55, 65];

    for (let h of hues) {
        for (let s of saturations) {
            for (let l of lightnesses) {
                const color = `hsl(${h}, ${s}%, ${l}%)`;
                if (!existingColors.includes(color)) {
                    return color;
                }
            }
        }
    }

    // Fallback: random color
    return `hsl(${Math.random() * 360}, 75%, 55%)`;
}

function getTypeColor(typeName, typeDisplay) {
    const key = typeName || typeDisplay;

    if (!typeColors[key]) {
        const existingColors = Object.values(typeColors);
        typeColors[key] = generateDistinctColor(existingColors);
        console.log(`ðŸŽ¨ Generated color for ${key}:`, typeColors[key]);
    }

    return typeColors[key];
}

  function isWhitespaceOnly(text) {
    if (typeof text !== 'string') {
      return true;
    }
    return text.replace(/[\s\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\u200b\u200c\u200d\u2060\ufeff]/g, '').length === 0;
  }

  function removeEmptyInlineAnnotations(container) {
    if (!container) {
      return;
    }
    container.querySelectorAll('.inline-annotation').forEach(span => {
      const content = span.textContent || '';
      if (isWhitespaceOnly(content)) {
        const parent = span.parentNode;
        while (span.firstChild) {
          parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
      }
    });
    container.normalize();
  }

  function trimLeadingWhitespace(container) {
    if (!container) return;
    while (container.firstChild && container.firstChild.nodeType === Node.TEXT_NODE && !container.firstChild.textContent.trim()) {
      container.removeChild(container.firstChild);
    }
    if (container.firstChild && container.firstChild.nodeType === Node.TEXT_NODE) {
      container.firstChild.textContent = container.firstChild.textContent.replace(/^\s+/, '');
      if (!container.firstChild.textContent.length) {
        container.removeChild(container.firstChild);
      }
    }
    if (container.firstElementChild) {
      container.firstElementChild.style.marginTop = '0';
    }
  }

  // Variable globale pour l'ID du document
  var DOCUMENT_ID = {{ document.id }};

  // Variables pour le cache Mistral - maintenant activ&eacute;es apr&egrave;s migrations
  var MISTRAL_CACHE_EXISTS = {{ document.mistral_analyzed|default:False|yesno:"true,false" }};
  var MISTRAL_CACHED_TYPES = {% if document.mistral_suggested_types %}{{ document.mistral_suggested_types|safe }}{% else %}[]{% endif %};
  var MISTRAL_DOCUMENT_LANGUAGE = "{{ document.mistral_document_language|default:'fr' }}";
  var MISTRAL_DOCUMENT_DOMAIN = "{{ document.mistral_document_domain|default:'Non d&eacute;fini' }}";

  // Variables pour le cache Llama - maintenant activ&eacute;es apr&egrave;s migrations
  var LLAMA_CACHED_TYPES = {% if document.llama_suggested_types %}{{ document.llama_suggested_types|safe }}{% else %}[]{% endif %};
  var LLAMA_CACHE_EXISTS = {% if document.llama_suggested_types %}true{% else %}false{% endif %};

  // Fonction de diagnostic pour les probl&egrave;mes d'espacement
  function debugSpacing(element, action) {
    const textContent = element.textContent;
    const innerHTML = element.innerHTML;
    console.log(` Debug ${action}:`, {
      'Contenu texte': JSON.stringify(textContent),
      'HTML interne': innerHTML,
      'Espaces d&eacute;tect&eacute;s': {
        'd&eacute;but': textContent.match(/^\s+/) ? textContent.match(/^\s+/)[0].length : 0,
        'fin': textContent.match(/\s+$/) ? textContent.match(/\s+$/)[0].length : 0,
        'total': textContent.length
      },
      'Attribut original': element.getAttribute('data-original-text') || 'Non d&eacute;fini'
    });
  }

  // Fonction pour ajouter une annotation au contenu structur&eacute;
  function addAnnotationToStructuredContent(annotation) {
    const structuredContent = document.querySelector('.structured-content-body');
    if (!structuredContent) {
        console.warn('? Structured content area not found');
        return;
    }

    const rawText = annotation.text || annotation.selected_text || '';
    if (isWhitespaceOnly(rawText)) {
        console.warn('? Skipping whitespace-only annotation for structured content', annotation.id);
        return;
    }

    const text = rawText;
    const type = annotation.type_display || annotation.type;
    const color = annotation.color || '#ffeb3b';
    const annotationId = annotation.id || `temp-${Date.now()}`;

    console.log(` Adding annotation to structured content: "${text.substring(0, 30)}..."`);

    // Convert color to RGB for gradient
    const rgb = hexToRgb(color || '#ffeb3b');
    const rgbValues = rgb ? `${rgb.r},${rgb.g},${rgb.b}` : '255,235,59';

    // Create tree walker to find text nodes
    const walker = document.createTreeWalker(
        structuredContent,
        NodeFilter.SHOW_TEXT,
        {
            acceptNode: function(node) {
                // Skip if already inside an annotation
                let parent = node.parentNode;
                while (parent && parent !== structuredContent) {
                    if (parent.classList && parent.classList.contains('inline-annotation')) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    parent = parent.parentNode;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        }
    );

    // Find and wrap the text
    let textNode;
    let found = false;

    while (textNode = walker.nextNode()) {
        const nodeText = textNode.textContent;
        const index = nodeText.indexOf(text);

        if (index !== -1) {
            found = true;
            console.log(` Found text at position ${index}`);

            // Split the text node
            const before = nodeText.substring(0, index);
            const match = nodeText.substring(index, index + text.length);
            const after = nodeText.substring(index + text.length);

            const leadingWhitespace = match.match(/^\s+/);
            const trailingWhitespace = match.match(/\s+$/);
            const leadingPart = leadingWhitespace ? leadingWhitespace[0] : '';
            const trailingPart = trailingWhitespace ? trailingWhitespace[0] : '';
            const coreText = match.substring(leadingPart.length, match.length - trailingPart.length);

            // Create annotation span
            const span = document.createElement('span');
            span.className = 'inline-annotation';
            span.dataset.annotationId = annotationId;
            span.dataset.annotationArea = 'structured';
            span.dataset.annotationRoot = 'true';
            span.style.cssText = `
                background-color: rgba(${rgbValues}, 0.2);
                color: inherit;
                font-family: inherit;
                font-size: inherit;
                font-weight: inherit;
                padding: 2px 4px;
                margin: 0 1px;
                border-radius: 3px;
                cursor: pointer;
            `;
            span.textContent = coreText.length > 0 ? coreText : match;

            // Store original text for restoration
            span.setAttribute('data-original-text', match);

            // Add label
            const label = document.createElement('span');
            label.className = 'ann-label';
            label.style.cssText = `
                font-size: 0.7rem;
                font-weight: bold;
                margin-left: 4px;
                padding: 2px 6px;
                border-radius: 4px;
                background: rgba(0,0,0,0.6);
                color: #fff;
                white-space: nowrap;
                display: inline;   //  label visible en permanence
                opacity: 1;
            `;
            label.textContent = type;
            span.appendChild(label);

            span.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                const annotationId = this.dataset.annotationId;
                const originalText = this.getAttribute('data-original-text');

                // Remove from DOM first
                if (originalText) {
                    const textNode = document.createTextNode(originalText);
                    this.parentNode.replaceChild(textNode, this);
                } else {
                    // fallback removal
                    const labelElement = this.querySelector('.ann-label');
                    let textContent = '';
                    for (let node of this.childNodes) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            textContent += node.textContent;
                        } else if (node !== labelElement && node.nodeType === Node.ELEMENT_NODE) {
                            textContent += node.textContent;
                        }
                    }
                    const textNode = document.createTextNode(textContent);
                    this.parentNode.replaceChild(textNode, this);
                }

                // Delete from database AND THEN update JSON
                deleteAnnotationAndUpdateJSON(annotationId);
            });

            // Replace the text node with our annotated version
            const parent = textNode.parentNode;
            if (before) parent.insertBefore(document.createTextNode(before), textNode);
            if (leadingPart) parent.insertBefore(document.createTextNode(leadingPart), textNode);
            if (coreText.length > 0) {
                parent.insertBefore(span, textNode);
            }
            if (trailingPart) parent.insertBefore(document.createTextNode(trailingPart), textNode);
            if (after) parent.insertBefore(document.createTextNode(after), textNode);
            if (coreText.length === 0) {
                span.remove();
            }
            parent.removeChild(textNode);

            break;
        }
    }

    if (!found) {
        console.warn(`? Could not find text in structured content: "${text.substring(0, 50)}..."`);
    }

    addAnnotationEventListeners();
}


  function addAnnotationEventListeners() {
    const annotations = document.querySelectorAll('.inline-annotation');
    annotations.forEach(annotation => {
      // Enlever les anciens gestionnaires pour &eacute;viter les doublons
      annotation.removeEventListener('mouseenter', showAnnotationLabel);
      annotation.removeEventListener('mouseleave', hideAnnotationLabel);
      annotation.removeEventListener('click', handleAnnotationClick);

      // Ajouter les nouveaux gestionnaires
      annotation.addEventListener('mouseenter', showAnnotationLabel);
      annotation.addEventListener('mouseleave', hideAnnotationLabel);
      annotation.addEventListener('click', handleAnnotationClick);
    });
  }

  // Fonctions pour g&eacute;rer l'affichage des labels
  function showAnnotationLabel(event) {
    const target = event.currentTarget || event.target;
    if (!target) {
        return;
    }

    let label = target.querySelector('.ann-label');

    if (!label && target.dataset && target.dataset.annotationId) {
        const rootSpan = document.querySelector(`.inline-annotation[data-annotation-id="${target.dataset.annotationId}"][data-annotation-root="true"]`);
        if (rootSpan) {
            label = rootSpan.querySelector('.ann-label');
        }
    }

    if (label) {
      label.style.display = 'block';
      label.style.opacity = '1';
    }
  }

  function hideAnnotationLabel(event) {
    const target = event.currentTarget || event.target;
    if (!target) {
        return;
    }

    let label = target.querySelector('.ann-label');

    if (!label && target.dataset && target.dataset.annotationId) {
        const rootSpan = document.querySelector(`.inline-annotation[data-annotation-id="${target.dataset.annotationId}"][data-annotation-root="true"]`);
        if (rootSpan) {
            label = rootSpan.querySelector('.ann-label');
        }
    }

    if (label) {
      label.style.opacity = '0';
      setTimeout(() => {
        if (label.style.opacity === '0') {
          label.style.display = 'none';
        }
      }, 200);
    }
  }

  function handleAnnotationClick(event) {
    event.preventDefault();
    event.stopPropagation();

    const target = event.currentTarget;
    if (!target || !target.dataset) {
        return;
    }

    const annotationId = target.dataset.annotationId;
    if (!annotationId) {
        return;
    }

    const annotationArea = target.dataset.annotationArea || 'raw';
    console.log('Annotation cliqu&eacute;e:', annotationId, 'area:', annotationArea);

    if (annotationArea === 'structured') {
        if (target.dataset.deleting === 'true') {
            return;
        }
        target.dataset.deleting = 'true';

        removeStructuredAnnotationFromDom(annotationId);

        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || getCookie('csrftoken');

        deleteAnnotationFromDB(annotationId, csrfToken);

        setTimeout(() => {
            loadAnnotationsInStructuredContent();
        }, 250);

        setTimeout(() => {
            loadAndRenderAnnotations();
        }, 350);
    } else {
        // Placeholder for raw text annotation handling (existing behavior)
        console.log(' Raw annotation clicked:', annotationId);
    }
  }

  // Fonction utilitaire pour supprimer une annotation en pr&eacute;servant l'espacement
  function removeAnnotationPreservingSpaces(annotationElement) {
    // Utiliser le texte original stock&eacute; pour une restauration exacte
    const originalText = annotationElement.getAttribute('data-original-text');

    if (originalText) {
      // Restauration exacte du texte original
      const textNode = document.createTextNode(originalText);
      annotationElement.parentNode.insertBefore(textNode, annotationElement);
      annotationElement.parentNode.removeChild(annotationElement);
      return textNode;
    } else {
      // M&eacute;thode de fallback si pas de texte stock&eacute;
      const labelElement = annotationElement.querySelector('.ann-label');
      let textContent = '';

      // Parcourir les nuds enfants pour extraire seulement le texte (pas le label)
      for (let node of annotationElement.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
          textContent += node.textContent;
        } else if (node !== labelElement && node.nodeType === Node.ELEMENT_NODE) {
          textContent += node.textContent;
        }
      }

      // Cr&eacute;er le nud de texte avec le contenu exact
      const textNode = document.createTextNode(textContent);
      annotationElement.parentNode.insertBefore(textNode, annotationElement);
      annotationElement.parentNode.removeChild(annotationElement);

      return textNode;
    }
  }

  function annotateWithGroqAll() {
    const btn = document.getElementById('groq-annotate-all-btn');
    const loading = document.getElementById('ai-loading');
    const validateBtn = document.getElementById('validate-page-btn');

    if (!btn || !loading || typeof DOCUMENT_ID === 'undefined') {
        console.error('Annotation impossible : ID du document non disponible ou &eacute;l&eacute;ments manquants');
        showErrorMessage('l&eacute;ments manquants pour l\'annotation du document');
        return;
    }

    btn.style.display = 'none';
    loading.style.display = 'flex';
    loading.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Annotation du document en cours...';

    fetch(`/annotation/groq/document/${DOCUMENT_ID}/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            mode: 'structured'  // Request structured mode annotations
        })
    })
    .then(handleResponse)
    .then(data => {
        if (data.success) {
            console.log(` AI annotation completed with mode: ${data.mode}`);

            showSuccessMessage(` Document annot&eacute;! ${data.total_annotations} annotations cr&eacute;&eacute;es`);

            if (data.total_pages > 0) {
                showAlert(`${data.total_pages} pages trait&eacute;es avec succ&egrave;s!`, 'success', '#10b981');
            }

            // CRITICAL: Reload both raw text AND structured content annotations
            setTimeout(() => {
                console.log(' Reloading annotations in both areas...');

                // Reload raw text area
                loadAndRenderAnnotations();

                // Reload structured content area
                loadAnnotationsInStructuredContent();

                console.log(' Both areas reloaded');
            }, 1500);
        } else {
            throw new Error(data.error || 'Erreur inconnue lors de l\'annotation');
        }
    })
    .catch(error => {
        console.error('Annotation Error:', error);
        showErrorMessage(`Erreur annotation: ${error.message}`);
    })
    .finally(() => {
        btn.style.display = 'flex';
        loading.style.display = 'none';
        loading.innerHTML = '<i class="fas fa-spinner fa-spin"></i> IA en cours...';
    });
}

  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function getXPath(node) {
    if (node.id) {
        return `//*[@id="${node.id}"]`;
    }

    if (node === document.body) {
        return '/html/body';
    }

    let ix = 0;
    let siblings = node.parentNode.childNodes;

    for (let i = 0; i < siblings.length; i++) {
        let sibling = siblings[i];
        if (sibling === node) {
            let path = getXPath(node.parentNode);
            let tag = node.tagName ? node.tagName.toLowerCase() : 'text()';
            return `${path}/${tag}[${ix + 1}]`;
        }
        if (sibling.nodeType === 1 && sibling.tagName === node.tagName) {
            ix++;
        }
    }
}

function getTextNodeOffset(textNode, endOffset) {
    return endOffset;
}

function restoreAnnotationFromXPath(annotation) {
    if (annotation.mode !== 'structured' || !annotation.start_xpath) {
        return false;
    }

    const structuredArea = document.getElementById("structured-annotation-area");
    if (!structuredArea) return false;

    try {
        const startNode = document.evaluate(
            annotation.start_xpath,
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
        ).singleNodeValue;

        const endNode = document.evaluate(
            annotation.end_xpath,
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
        ).singleNodeValue;

        if (!startNode || !endNode) {
            console.warn('Could not resolve XPath for annotation:', annotation.id);
            return false;
        }

        const range = document.createRange();
        const startTextNode = findTextNodeAtOffset(startNode, annotation.start_offset);
        const endTextNode = findTextNodeAtOffset(endNode, annotation.end_offset);

        if (!startTextNode || !endTextNode) {
            console.warn('Could not find text nodes for annotation:', annotation.id);
            return false;
        }

        range.setStart(startTextNode.node, startTextNode.offset);
        range.setEnd(endTextNode.node, endTextNode.offset);

        const rangeText = range.toString();
        if (isWhitespaceOnly(rangeText)) {
            console.warn('? Skipping whitespace-only XPath annotation:', annotation.id);
            return false;
        }

        // CAPTURE COMPLTE DE L'TAT ORIGINAL avant toute modification
        const originalState = {
            startContainer: range.startContainer,
            endContainer: range.endContainer,
            startOffset: range.startOffset,
            endOffset: range.endOffset,
            originalText: rangeText,

            // Capturer l'&eacute;tat des nuds de texte complets pour restauration exacte
            beforeText: '',
            selectedText: rangeText,
            afterText: ''
        };4

        // Capturer le texte avant la s&eacute;lection dans le m&ecirc;me nud
        if (range.startContainer.nodeType === Node.TEXT_NODE) {
            originalState.beforeText = range.startContainer.textContent.substring(0, range.startOffset);
            originalState.afterText = range.startContainer.textContent.substring(range.endOffset);
        }

        console.log(' tat original captur&eacute;:', originalState);

        const span = document.createElement("span");
        span.classList.add("inline-annotation");
        span.setAttribute("data-annotation-id", annotation.id);
        span.style.background = annotation.color;
        span.style.padding = "2px 4px";
        span.style.margin = "0 1px";
        span.style.borderRadius = "3px";
        span.style.cursor = "pointer";

        const fragment = range.cloneContents();
        span.appendChild(fragment);

        // Stocker l'&eacute;tat complet pour restauration exacte
        span.setAttribute('data-original-text', originalState.selectedText);
        span.setAttribute('data-before-text', originalState.beforeText);
        span.setAttribute('data-after-text', originalState.afterText);
        span.setAttribute('data-start-offset', originalState.startOffset);
        span.setAttribute('data-end-offset', originalState.endOffset);

        console.log(' Donn&eacute;es stock&eacute;es dans span:', {
            originalText: originalState.selectedText,
            beforeText: originalState.beforeText,
            afterText: originalState.afterText
        });

        range.deleteContents();
        range.insertNode(span);

        const label = document.createElement("span");
        label.className = "ann-label";
        label.textContent = annotation.type_display;
        span.appendChild(label);

        span.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();

            // Debug avant suppression
            debugSpacing(this, 'avant suppression');

            // NOUVELLE MTHODE: Restauration compl&egrave;te avec contexte
            const originalText = this.getAttribute('data-original-text');
            const beforeText = this.getAttribute('data-before-text');
            const afterText = this.getAttribute('data-after-text');

            if (originalText !== null && beforeText !== null && afterText !== null) {
                console.log('  Restauration compl&egrave;te avec contexte:', {
                    before: JSON.stringify(beforeText),
                    selected: JSON.stringify(originalText),
                    after: JSON.stringify(afterText)
                });

                // Reconstruire le nud de texte complet avec son contexte
                const fullText = beforeText + originalText + afterText;
                const textNode = document.createTextNode(fullText);

                // Remplacer le parent du span par le nud de texte reconstitu&eacute;
                const parentElement = this.parentNode;
                const grandParent = parentElement.parentNode;

                if (grandParent) {
                    grandParent.insertBefore(textNode, parentElement);
                    grandParent.removeChild(parentElement);
                } else {
                    parentElement.insertBefore(textNode, this);
                    parentElement.removeChild(this);
                }

                console.log(' Texte complet restaur&eacute;:', JSON.stringify(fullText));
            } else {
                // Fallback vers l'ancienne m&eacute;thode
                const originalTextFallback = this.getAttribute('data-original-text');

                if (originalTextFallback) {
                    console.log(' Restauration fallback avec texte original:', JSON.stringify(originalTextFallback));
                    const textNode = document.createTextNode(originalTextFallback);
                    this.parentNode.insertBefore(textNode, this);
                    this.parentNode.removeChild(this);
                    console.log(' Texte restaur&eacute; (fallback):', JSON.stringify(textNode.textContent));
                } else {
                    console.warn('? Pas de texte original stock&eacute;, utilisation de fallback manuel');

                    const labelElement = this.querySelector('.ann-label');
                    let textContent = '';

                    for (let node of this.childNodes) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            textContent += node.textContent;
                        } else if (node !== labelElement && node.nodeType === Node.ELEMENT_NODE) {
                            textContent += node.textContent;
                        }
                    }

                    console.log(' Fallback manuel texte extrait:', JSON.stringify(textContent));
                    const textNode = document.createTextNode(textContent);
                    this.parentNode.insertBefore(textNode, this);
                    this.parentNode.removeChild(this);
                }
            }

            deleteAnnotationFromDB(annotation.id);
        });

        console.log(' Restored annotation from XPath:', annotation.id);
        return true;

    } catch (error) {
        console.error('Error restoring annotation from XPath:', error);
        return false;
    }
}

function findTextNodeAtOffset(element, offset) {
    let currentOffset = 0;
    const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );

    let node;
    while (node = walker.nextNode()) {
        const nodeLength = node.textContent.length;
        if (currentOffset + nodeLength >= offset) {
            return {
                node: node,
                offset: offset - currentOffset
            };
        }
        currentOffset += nodeLength;
    }

    return null;
}


</script>

<!-- Tous les styles CSS existants restent identiques -->
<style>
/* NUCLEAR OPTION: Override ALL modal conflicts */
.context-menu {
    position: absolute;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 10000;
    padding: 0;
    min-width: 150px;
}
#all-pages-content {
    overflow-x: auto;
    width: 100%;
    max-width: 100%;
}

#all-pages-content table {
    min-width: 600px; /* Minimum width to show all columns */
    width: auto !important;
}


/* JSON Tab Styles  */
.json-tab-btn {
    padding: 0.5rem 1rem;
    background: rgba(255,255,255,0.05);
    border: none;
    border-radius: 6px 6px 0 0;
    cursor: pointer;
    color: rgba(255,255,255,0.5);
    font-weight: 600;
    font-size: 0.85rem;
    transition: all 0.2s ease;
    border-bottom: 2px solid transparent;
}

.json-tab-btn.active {
    background: rgba(16,185,129,0.2);
    color: #10b981;
    border-bottom: 2px solid #10b981;
}

.json-tab-btn:hover:not(.active) {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.7);
}
.json-tab-btn i {
    margin-right: 0.25rem;
}

/* JSON Syntax Highlighting */
.json-key { color: #60a5fa; }
.json-string { color: #34d399; }
.json-number { color: #fbbf24; }
.json-boolean { color: #f87171; }
.json-null { color: #94a3b8; }

.context-menu-item {
    padding: 8px 12px;
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    font-size: 14px;
    color: #333;
    transition: background-color 0.2s;
}

.context-menu-item:hover {
    background-color: #f8f9fa;
}

.context-menu-item.danger {
    color: #dc3545;
}

.context-menu-item.danger:hover {
    background-color: #f8d7da;
}

/* Hide context menu initially */
.context-menu.hidden {
    display: none;
}
/* Force modal to appear above EVERYTHING */
.modal {
    z-index: 999999 !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0, 0, 0, 0.5) !important;
    display: none !important;
}

.modal.show {
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

/* Force backdrop to be clickable and properly positioned */
.modal-backdrop {
    z-index: 999998 !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background-color: rgba(0, 0, 0, 0.5) !important;
}

/* Force modal dialog to be above backdrop and clickable */
.modal-dialog {
    z-index: 1000000 !important;
    position: relative !important;
    margin: 1.75rem auto !important;
    max-width: 500px !important;
    width: 90% !important;
    pointer-events: auto !important;
}

/* Force modal content styling */
.modal-content {
    background: white !important;
    border: none !important;
    border-radius: 0.5rem !important;
    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8) !important;
    pointer-events: auto !important;
    position: relative !important;
    z-index: 1000001 !important;
}

.modal-header {
    background: #f8f9fa !important;
    border-bottom: 1px solid #dee2e6 !important;
    padding: 1rem 1.5rem !important;
    border-radius: 0.5rem 0.5rem 0 0 !important;
}

.modal-title {
    color: #495057 !important;
    font-weight: 500 !important;
    margin: 0 !important;
}

.modal-body {
    background: white !important;
    padding: 1.5rem !important;
    color: #495057 !important;
}

.modal-footer {
    background: #f8f9fa !important;
    border-top: 1px solid #dee2e6 !important;
    padding: 1rem 1.5rem !important;
    border-radius: 0 0 0.5rem 0.5rem !important;
}

/* Force all form elements to work properly */
.modal input,
.modal select,
.modal textarea {
    background: white !important;
    border: 1px solid #ced4da !important;
    color: #495057 !important;
    padding: 0.375rem 0.75rem !important;
    border-radius: 0.25rem !important;
    width: 100% !important;
    pointer-events: auto !important;
    z-index: 1000002 !important;
    position: relative !important;
}

.modal input:focus,
.modal select:focus,
.modal textarea:focus {
    border-color: #86b7fe !important;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25) !important;
    outline: 0 !important;
}

.modal .form-label {
    color: #495057 !important;
    font-weight: 500 !important;
    margin-bottom: 0.5rem !important;
}

.modal .btn {
    pointer-events: auto !important;
    z-index: 1000002 !important;
    position: relative !important;
}

.modal .btn-close {
    background: transparent !important;
    border: none !important;
    color: #000 !important;
    opacity: 0.5 !important;
    pointer-events: auto !important;
    z-index: 1000002 !important;
    position: relative !important;
}

.modal .btn-close:hover {
    opacity: 1 !important;
}

/* Remove ANY other z-index that might interfere */
.annotation-header,
.annotation-types-panel,
.page-navigation,
.text-content-card,
.annotations-list,
.learning-dashboard-widget {
    z-index: auto !important;
    position: relative !important;
}

/* Ensure the page content doesn't interfere */
.app-container,
.site-header,
body {
    z-index: auto !important;
}

/* Force click events to work */
.modal * {
    pointer-events: auto !important;
}

.modal-dialog * {
    pointer-events: auto !important;
}

.modal-content * {
    pointer-events: auto !important;
}
@keyframes highlight-pulse {
    0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
    50% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0.3); }
    100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
}

.annotation-text-clickable:hover {
    background-color: #e7f3ff !important;
    border-radius: 3px;
    padding: 1px 3px;
}

/* Styles pour l'analyse r&eacute;glementaire */
.regulatory-analysis-panel {
  background: linear-gradient(120deg, #f0f9ff 70%, #e0f2fe 100%);
  border: 1.5px solid var(--pharma-info);
  border-radius: var(--pharma-radius);
  margin-bottom: 2rem;
  box-shadow: var(--pharma-shadow);
  padding: 2rem;
}

.regulatory-stats {
  display: flex;
  gap: 1.5rem;
  margin-bottom: 1.5rem;
}

.regulatory-stat {
  background: var(--pharma-bg-card);
  border: 1px solid var(--pharma-border);
  border-radius: var(--pharma-radius-sm);
  padding: 1rem 1.2rem;
  text-align: center;
  flex: 1;
  box-shadow: 0 2px 8px rgba(56,189,248,0.08);
}

.regulatory-stat-value {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--pharma-info);
  display: block;
}

.regulatory-stat-label {
  font-size: 0.85rem;
  color: var(--pharma-text-soft);
  margin-top: 0.2rem;
}

.btn-regulatory {
  background: linear-gradient(90deg, var(--pharma-info), #0ea5e9);
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-weight: 700;
  font-size: 1.04rem;
  box-shadow: 0 4px 12px rgba(56,189,248,0.13);
  transition: var(--pharma-transition);
}

.btn-regulatory:hover {
  background: linear-gradient(90deg, #0ea5e9, var(--pharma-primary));
  color: #fff;
}

.btn-regulatory:disabled {
  background: #e5e7eb;
  color: #9ca3af;
  cursor: not-allowed;
}

.regulatory-progress {
  background: var(--pharma-bg-card);
  border-radius: 8px;
  padding: 0.5rem;
  margin: 1rem 0;
}

.progress-bar-regulatory {
  background: linear-gradient(90deg, var(--pharma-info), var(--pharma-accent));
  height: 8px;
  border-radius: 4px;
  transition: width 0.3s ease;
}

.page-regulatory-analysis {
  background: var(--pharma-glass);
  border: 1.5px solid var(--pharma-info);
  border-radius: var(--pharma-radius-sm);
  padding: 1.5rem;
  margin-top: 1rem;
}

.importance-score {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.3rem 1rem;
  border-radius: 999px;
  font-weight: 600;
  font-size: 0.9rem;
}

/* Split Screen Styles - RESPONSIVE FIX */
.split-screen-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-top: 1rem;
    max-width: 100%;
    overflow: hidden; /* Prevent overflow */
}

.left-panel, .right-panel {
    border-radius: var(--pharma-radius);
    background: var(--pharma-bg-card);
    box-shadow: var(--pharma-shadow);
    min-width: 0; /* Allow flex shrinking */
    overflow: hidden; /* Contain content */
}

.left-panel {
    border: 2px solid var(--pharma-primary);
}

.right-panel {
    border: 2px solid var(--pharma-accent);
    background: #f0fdf4;
    position: relative;
}

.panel-body {
    padding: 1rem;
    max-height: 65vh; /* Reduced from 70vh */
    overflow-y: auto;
    overflow-x: hidden; /* Prevent horizontal scroll */
    word-wrap: break-word; /* Break long words */
}

/* JSON Display - Prevent horizontal overflow */
#page-json-display, #document-json-display {
    max-width: 100%;
    overflow-x: auto !important;
    white-space: pre-wrap !important; /* Wrap long lines */
    word-break: break-all; /* Break long strings */
}

/* Structured content - Prevent overflow */
.structured-content-body {
    max-width: 100%;
    overflow-x: hidden;
    word-wrap: break-word;
}

/* Responsive adjustments */
@media (max-width: 1400px) {
    .split-screen-container {
        gap: 0.75rem;
    }

    .panel-body {
        padding: 0.75rem;
        max-height: 60vh;
    }
}

@media (max-width: 1200px) {
    .split-screen-container {
        grid-template-columns: 1fr;
        gap: 1rem;
    }

    .right-panel {
        max-height: 50vh;
    }

    .panel-body {
        max-height: 45vh;
    }
}

@media (max-width: 768px) {
    .panel-body {
        padding: 0.5rem;
        max-height: 40vh;
    }

    .panel-header {
        padding: 0.75rem 1rem;
        flex-direction: column;
        gap: 0.5rem;
    }
}

.importance-score.critical {
  background: linear-gradient(90deg, #ef4444, #dc2626);
  color: #fff;
}

.importance-score.high {
  background: linear-gradient(90deg, #f59e0b, #d97706);
  color: #fff;
}

.importance-score.medium {
  background: linear-gradient(90deg, var(--pharma-info), var(--pharma-primary));
  color: #fff;
}

.importance-score.low {
  background: #e5e7eb;
  color: #6b7280;
}

.regulatory-obligations {
  margin-top: 1rem;
}

.obligation-item {
  background: var(--pharma-bg-card);
  border: 1px solid var(--pharma-border);
  border-radius: 8px;
  padding: 0.8rem 1rem;
  margin-bottom: 0.8rem;
  border-left: 4px solid var(--pharma-warn);
}

.obligation-severity.high {
  border-left-color: var(--pharma-error);
}

.obligation-severity.medium {
  border-left-color: var(--pharma-warn);
}

.obligation-severity.low {
  border-left-color: var(--pharma-info);
}

.regulatory-loading {
  color: var(--pharma-info);
  font-weight: 500;
  margin-left: 1rem;
  display: none;
}

.key-points-list {
  margin-top: 1rem;
}

.key-point {
  background: #f0f9ff;
  border: 1px solid #e0f2fe;
  border-radius: 6px;
  padding: 0.6rem 0.8rem;
  margin-bottom: 0.5rem;
  font-size: 0.95rem;
  color: var(--pharma-text);
}

.authorities-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 0.8rem;
}

.authority-tag {
  background: linear-gradient(90deg, #8b5cf6, #7c3aed);
  color: #fff;
  padding: 0.25rem 0.8rem;
  border-radius: 999px;
  font-size: 0.85rem;
  font-weight: 500;
}

.deadlines-list {
  margin-top: 1rem;
}

.deadline-item {
  background: #fef3c7;
  border: 1px solid #fbbf24;
  border-radius: 6px;
  padding: 0.6rem 0.8rem;
  margin-bottom: 0.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.deadline-timeframe {
  background: var(--pharma-warn);
  color: #fff;
  padding: 0.2rem 0.6rem;
  border-radius: 999px;
  font-size: 0.8rem;
  font-weight: 600;
}
</style>

<!-- Styles CSS pharma existants conserv&eacute;s identiques -->
<style>
/* Pharma color variables */
:root {
  --pharma-primary: #0ea5e9;
  --pharma-primary-dark: #0284c7;
  --pharma-accent: #10b981;
  --pharma-bg: #f8fafc;
  --pharma-bg-card: rgba(255,255,255,0.95);
  --pharma-glass: rgba(14,165,233,0.10);
  --pharma-border: #cbd5e1;
  --pharma-shadow: 0 8px 32px 0 rgba(14, 165, 233, 0.07);
  --pharma-text: #1e293b;
  --pharma-text-soft: #64748b;
  --pharma-valid: #22c55e;
  --pharma-warn: #f59e0b;
  --pharma-error: #ef4444;
  --pharma-info: #38bdf8;
  --pharma-radius: 18px;
  --pharma-radius-sm: 12px;
  --pharma-font: 'Inter', sans-serif;
  --pharma-transition: all 0.28s cubic-bezier(.4,0,.2,1);
}

.main-content {
    width: 100%;
    max-width: 100vw;
    padding: 0 1rem;
    box-sizing: border-box;
    overflow-x: hidden;
}

/* Ensure body doesn't overflow */
body {
    overflow-x: hidden;
    max-width: 100vw;
}

/* Annotation header */
.annotation-header {
  background: var(--pharma-bg-card);
  border-radius: var(--pharma-radius);
  box-shadow: var(--pharma-shadow);
  border: 1px solid var(--pharma-border);
  padding: 1.5rem 2rem;
  margin-bottom: 2.2rem;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1.5rem;
  animation: fadeInUp 0.5s;
}

.header-info h2 {
  color: var(--pharma-primary-dark);
  font-size: 1.45rem;
  font-weight: 700;
  margin-bottom: 0.3rem;
  display: flex;
  align-items: center;
  gap: 0.6rem;
}

.document-meta {
  display: flex;
  gap: 1.2rem;
  font-size: 0.98rem;
  margin-top: 0.2rem;
}

.meta-item {
  color: var(--pharma-text-soft);
  gap: 0.3rem;
  display: flex;
  align-items: center;
}

.header-actions .btn-outline {
  background: var(--pharma-glass);
  border: 1.5px solid var(--pharma-primary);
  color: var(--pharma-primary-dark);
  border-radius: var(--pharma-radius-sm);
  font-size: 1rem;
  padding: 0.6rem 1.3rem;
  font-weight: 500;
  transition: var(--pharma-transition);
}
.header-actions .btn-outline:hover {
  background: var(--pharma-primary);
  color: #fff;
  border-color: var(--pharma-primary-dark);
  transform: translateY(-2px) scale(1.04);
}

/* Annotation Types Panel */
.annotation-types-panel {
  background: linear-gradient(120deg, #f0fdfa 70%, #bae6fd 100%);
  border: 1.5px solid var(--pharma-primary-light, #38bdf8);
  border-radius: var(--pharma-radius);
  margin-bottom: 2rem;
  box-shadow: var(--pharma-shadow);
  padding: 2rem;
}

.annotation-types-panel h3 {
  font-size: 1.2rem;
  color: var(--pharma-primary-dark);
  margin-bottom: 0.35rem;
  font-weight: 600;
}

.instructions,
.help-text {
  color: var(--pharma-text-soft);
  font-size: 0.97rem;
  opacity: 0.88;
  margin-bottom: 0.7rem;
}

.annotation-types {
  display: flex;
  flex-wrap: wrap;
  gap: 0.65rem;
  margin-bottom: 0.8rem;
}

.annotation-type-btn {
  border-radius: 999px;
  background: var(--pharma-bg-card);
  border: 2px solid var(--pharma-primary);
  color: var(--pharma-primary-dark);
  font-weight: 500;
  font-size: 1rem;
  padding: 0.45rem 1.25rem;
  box-shadow: 0 2px 10px rgba(14,165,233,0.05);
  transition: var(--pharma-transition);
  outline: none;
}
.annotation-type-btn:hover, .annotation-type-btn.active {
  background: var(--pharma-primary);
  color: #fff;
  transform: translateY(-2px) scale(1.07);
  border-color: var(--pharma-primary-dark);
  box-shadow: 0 6px 18px rgba(14,165,233,0.14);
}
.annotation-type-btn-add {
  background: linear-gradient(90deg, var(--pharma-accent), var(--pharma-primary));
  border: none;
  color: #fff;
  font-weight: 600;
  border-radius: 999px;
  font-size: 1rem;
  padding: 0.45rem 1.35rem;
  transition: var(--pharma-transition);
  box-shadow: 0 2px 12px rgba(16,185,129,0.11);
}
.annotation-type-btn-add:hover {
  background: linear-gradient(90deg, var(--pharma-primary), var(--pharma-accent));
  transform: translateY(-1.5px) scale(1.06);
}

.current-mode {
  background: var(--pharma-primary-dark);
  color: #fff;
  border-radius: 12px;
  padding: 0.23rem 1rem;
  font-size: 1.03rem;
  margin-left: 0.7rem;
  font-weight: 600;
}

/* Context Menu */
.context-menu {
  position: absolute;
  background: var(--pharma-bg-card);
  border: 1.5px solid var(--pharma-border);
  border-radius: 12px;
  box-shadow: 0 6px 24px rgba(0,0,0,0.13);
  min-width: 170px;
  z-index: 10010;
  font-size: 1rem;
  padding: 0.1rem;
}
.context-menu-item {
  color: var(--pharma-text);
  padding: 9px 14px;
  background: none;
  width: 100%;
  border: none;
  border-radius: 8px;
  text-align: left;
  transition: background .18s;
}
.context-menu-item:hover { background: #e0f2fe; }
.context-menu-item.danger { color: var(--pharma-error); }
.context-menu-item.danger:hover { background: #ffe4e6; }
.context-menu.hidden { display: none; }

/* Page Navigation */
.page-navigation {
  background: var(--pharma-bg-card);
  border: 1px solid var(--pharma-border);
  border-radius: var(--pharma-radius);
  box-shadow: var(--pharma-shadow);
  padding: 1.5rem 2rem;
  margin-bottom: 2.1rem;
}

/* Actions Container */
.actions-container {
  margin-top: 1.5rem;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--pharma-border);
}

.action-group {
  background: var(--pharma-glass);
  border: 1px solid rgba(59, 130, 246, 0.1);
  border-radius: var(--pharma-radius-sm);
  padding: 1.2rem;
  transition: var(--pharma-transition);
}

.action-group:hover {
  border-color: rgba(59, 130, 246, 0.2);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.08);
}

.group-title {
  font-size: 0.9rem;
  font-weight: 700;
  color: var(--pharma-primary-dark);
  margin-bottom: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.group-title::before {
  content: '';
  width: 3px;
  height: 16px;
  background: linear-gradient(to bottom, var(--pharma-primary), var(--pharma-accent));
  border-radius: 2px;
}

.buttons-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.8rem;
  align-items: center;
}

/* Ajustements des boutons pour la nouvelle disposition */
.buttons-row .btn-groq,
.buttons-row .btn-validate,
.buttons-row .btn-json-page,
.buttons-row .btn-json-document,
.buttons-row .btn-view-json,
.buttons-row .btn-expert {
  font-size: 0.9rem;
  padding: 0.6rem 1.2rem;
  flex: 1;
  min-width: 140px;
  justify-content: center;
}

#page-json-display[contenteditable="true"],
#document-json-display[contenteditable="true"] {
    outline: 1px dashed rgba(59,130,246,0.3);
    transition: border-color 0.3s ease;
}

#page-json-display[contenteditable="true"]:focus,
#document-json-display[contenteditable="true"]:focus {
    outline: 2px solid rgba(59,130,246,0.5);
}

/* Loading indicators container */
.loading-indicators {
  grid-column: 1 / -1;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: rgba(59, 130, 246, 0.05);
  border-radius: var(--pharma-radius-sm);
  border: 1px dashed rgba(59, 130, 246, 0.2);
}

.page-controls { display: flex; align-items: center; gap: 1.5rem; }
.page-selector select {
  padding: 0.48rem 1.1rem;
  border-radius: 12px;
  border: 1.5px solid var(--pharma-primary);
  background: var(--pharma-glass);
  color: var(--pharma-primary-dark);
  font-weight: 600;
  font-size: 1rem;
  outline: none;
  transition: border .18s;
}
.page-selector select:focus {
  border-color: var(--pharma-accent);
}

.nav-btn {
  background: var(--pharma-primary-dark);
  color: #fff;
  border-radius: 11px;
  font-size: 1rem;
  padding: 0.5rem 1.4rem;
  font-weight: 600;
  border: none;
  transition: var(--pharma-transition);
  box-shadow: 0 3px 10px rgba(14,165,233,0.11);
  outline: none;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.nav-btn:hover {
  background: var(--pharma-primary);
  color: #fff;
  transform: scale(1.04) translateY(-1px);
  text-decoration: none;
}

.nav-btn-icon {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  padding: 0;
  font-size: 1.2rem;
  background: linear-gradient(135deg, var(--pharma-primary-dark), var(--pharma-primary));
  box-shadow: 0 4px 15px rgba(14,165,233,0.15);
  position: relative;
  overflow: hidden;
}

.nav-btn-icon:hover {
  background: linear-gradient(135deg, var(--pharma-primary), var(--pharma-accent));
  transform: scale(1.1) translateY(-2px);
  box-shadow: 0 6px 20px rgba(14,165,233,0.25);
}

.nav-btn-icon:active {
  transform: scale(0.95) translateY(0);
}

.nav-btn-icon i {
  font-size: 1.3rem;
  transition: var(--pharma-transition);
}

.nav-btn-icon:hover i {
  transform: scale(1.1);
}

/* AI, Validate, Expert Buttons */
.ai-controls {
  display: flex;
  align-items: center;
  gap: 1.1rem;
  flex-wrap: wrap;
}

.btn-groq {
  background: linear-gradient(90deg, var(--pharma-primary), var(--pharma-info));
  color: #fff;
  font-weight: 700;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-size: 1.04rem;
  border: none;
  box-shadow: 0 4px 18px rgba(56,189,248,0.08);
  transition: var(--pharma-transition);
}
.btn-groq:hover { background: linear-gradient(90deg, var(--pharma-info), var(--pharma-primary-dark)); }

.btn-mistral {
  background: linear-gradient(90deg, #7D4CDB, #4A3094);
  color: #fff;
  font-weight: 700;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-size: 1.04rem;
  border: none;
  box-shadow: 0 4px 18px rgba(77,76,172,0.15);
  transition: var(--pharma-transition);
  position: relative;
}
.btn-mistral:hover { background: linear-gradient(90deg, #9B6CFF, #7D4CDB); }

.mistral-loading {
  position: absolute;
  right: 10px;
  width: 15px;
  height: 15px;
  color: white;
}

.btn-validate {
  background: var(--pharma-accent);
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-weight: 700;
  font-size: 1.04rem;
  box-shadow: 0 4px 12px rgba(16,185,129,0.09);
  transition: var(--pharma-transition);
}
.btn-validate:disabled {
  background: #e5e7eb;
  color: #9ca3af;
  cursor: not-allowed;
}
.btn-validate:hover:not(:disabled) {
  background: #059669;
}

/* NOUVEAUX STYLES POUR LES BOUTONS JSON */
.btn-json-page {
  background: linear-gradient(90deg, #10b981, #059669);
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-weight: 700;
  font-size: 1.04rem;
  box-shadow: 0 4px 12px rgba(16,185,129,0.13);
  transition: var(--pharma-transition);
}

.btn-json-page:hover {
  background: linear-gradient(90deg, #059669, #047857);
  color: #fff;
}

.btn-json-document {
  background: linear-gradient(90deg, #f59e0b, #d97706);
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-weight: 700;
  font-size: 1.04rem;
  box-shadow: 0 4px 12px rgba(245,158,11,0.13);
  transition: var(--pharma-transition);
}

.btn-json-document:hover {
  background: linear-gradient(90deg, #d97706, #b45309);
  color: #fff;
}

/* Groupement des actions JSON par paires */
.json-action-pair {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex: 1;
}

/* Boutons JSON ic&ocirc;nes stylis&eacute;s */
.btn-view-json-page,
.btn-view-json-global {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  text-decoration: none;
  font-size: 1.2rem;
  transition: var(--pharma-transition);
  box-shadow: 0 3px 12px rgba(0,0,0,0.1);
  position: relative;
  overflow: hidden;
}

.btn-view-json-page {
  background: linear-gradient(135deg, #10b981, #059669);
  color: #fff;
  border: 2px solid #059669;
}

.btn-view-json-page:hover {
  background: linear-gradient(135deg, #059669, #047857);
  color: #fff;
  transform: scale(1.1) translateY(-2px);
  box-shadow: 0 6px 20px rgba(16,185,129,0.25);
  text-decoration: none;
}

.btn-view-json-global {
  background: linear-gradient(135deg, #f59e0b, #d97706);
  color: #fff;
  border: 2px solid #d97706;
}

.btn-view-json-global:hover {
  background: linear-gradient(135deg, #d97706, #b45309);
  color: #fff;
  transform: scale(1.1) translateY(-2px);
  box-shadow: 0 6px 20px rgba(245,158,11,0.25);
  text-decoration: none;
}

.btn-view-json-page:active,
.btn-view-json-global:active {
  transform: scale(0.95) translateY(0);
}

.btn-view-json-page i,
.btn-view-json-global i {
  font-size: 1.3rem;
  transition: var(--pharma-transition);
}

.btn-view-json-page:hover i,
.btn-view-json-global:hover i {
  transform: scale(1.1);
}

/* Visual JSON Editor Styles */
.annotation-card {
    background: #1e293b;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    position: relative;
    transition: all 0.2s ease;
}

.annotation-card:hover {
    border-color: rgba(59,130,246,0.5);
    background: #2d3748;
}

.annotation-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.annotation-id {
    font-size: 0.7rem;
    color: #94a3b8;
    background: rgba(255,255,255,0.1);
    padding: 2px 8px;
    border-radius: 4px;
}

.annotation-actions {
    display: flex;
    gap: 4px;
}

.card-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    color: white;
    font-size: 0.75rem;
    transition: all 0.2s ease;
}

.card-btn:hover {
    background: rgba(255,255,255,0.2);
}

.card-btn.delete {
    background: rgba(239,68,68,0.2);
    color: #fca5a5;
}

.card-btn.delete:hover {
    background: rgba(239,68,68,0.4);
}

.annotation-text-display {
    background: rgba(16,185,129,0.1);
    border-left: 3px solid #10b981;
    padding: 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    color: #d1fae5;
    margin-bottom: 8px;
    word-break: break-word;
}

.annotation-type-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
}

.empty-annotations {
    text-align: center;
    padding: 40px 20px;
    color: #64748b;
}

.empty-annotations i {
    font-size: 3rem;
    opacity: 0.3;
    margin-bottom: 10px;
}

.btn-expert {
  background: linear-gradient(90deg, #6d28d9, #4c1d95 90%);
  color: #fff;
  font-weight: 700;
  border-radius: 12px;
  padding: 0.65rem 1.4rem;
  font-size: 1.04rem;
  border: none;
  box-shadow: 0 4px 12px rgba(109,40,217,0.13);
  transition: var(--pharma-transition);
}
.btn-expert:hover { background: linear-gradient(90deg, #7c3aed, #a78bfa 80%); }

.btn-success {
  background: var(--pharma-accent);
  color: #fff !important;
  border-radius: 12px;
  font-weight: 700;
  padding: 0.65rem 1.4rem;
}

.ai-loading, .learning-progress, .regulatory-loading, .json-loading {
  color: var(--pharma-primary-dark);
  font-weight: 500;
  margin-left: 1rem;
}

.json-loading {
  color: var(--pharma-accent);
  font-weight: 500;
  margin-left: 1rem;
}

/* Text Content (Zone principale d'annotation) */
.text-content-card {
  background: var(--pharma-bg-card);
  border-radius: var(--pharma-radius);
  box-shadow: var(--pharma-shadow);
  border: 1.5px solid var(--pharma-primary-light, #38bdf8);
  margin-bottom: 2.2rem;
  padding: 2rem 2.1rem;
  animation: fadeInUp 0.6s;
}

.text-content-card h3 {
  color: var(--pharma-primary-dark);
  font-size: 1.18rem;
  font-weight: 700;
  margin-bottom: 1.2rem;
  display: flex;
  align-items: center;
  gap: 0.7rem;
}

.page-status {
  padding: 0.25rem 1rem;
  border-radius: 999px;
  font-size: 0.92rem;
  font-weight: 700;
  margin-left: 1.1rem;
  box-shadow: 0 2px 7px rgba(59,130,246,0.05);
}
.page-status.validated-human {
  background: #d1fae5;
  color: #047857;
}
.page-status.annotated {
  background: #bae6fd;
  color: var(--pharma-primary-dark);
}
.page-status.pending {
  background: #fef3c7;
  color: #92400e;
}

/* Text content - Enhanced for PDF-like appearance */
.text-content {
    background: #fafbfc;
    border: 1px solid var(--pharma-border);
    border-radius: 12px;
    padding: 2rem;
    line-height: 1.8;
    font-size: 1.05rem;
    color: var(--pharma-text);
    white-space: pre-wrap;
    word-wrap: break-word;
    min-height: 400px;
    width: 100%;
    max-width: 100%;
    cursor: text;
    font-family: 'Inter', 'Georgia', 'Times New Roman', serif;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    hyphens: auto;
    text-align: justify;
    text-justify: inter-word;
    letter-spacing: 0.01em;
    word-spacing: 0.05em;
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
    border: 2px solid rgba(59, 130, 246, 0.1);
    transition: border-color 0.3s ease;
  }

  .text-content:hover {
    border-color: rgba(59, 130, 246, 0.2);
  }

  /* Add visual structure for better readability */
  .text-content::before {
    content: "";
    display: block;
    width: 100%;
    height: 2px;
    background: linear-gradient(to right,
      transparent,
      rgba(59, 130, 246, 0.2),
      transparent
    );
    margin-bottom: 1.5rem;
  }

  /* Enhanced paragraph spacing for PDF-like structure */
  .text-content p {
    margin-bottom: 1.2rem;
    text-indent: 1.5rem;
  }

  .text-content p:first-child {
    text-indent: 0;
  }

/* Annotations List (as cards) */
.annotations-list {
  background: var(--pharma-bg-card);
  border-radius: var(--pharma-radius);
  box-shadow: var(--pharma-shadow);
  border: 1.5px solid var(--pharma-border);
  padding: 1.8rem 2rem;
  margin-bottom: 1.8rem;
}
.annotations-list h3 {
  color: var(--pharma-primary-dark);
  font-size: 1.13rem;
  margin-bottom: 1.1rem;
  display: flex;
  align-items: center;
  gap: 0.7rem;
}

.annotation-item {
  background: var(--pharma-glass);
  border: 1.5px solid var(--pharma-border);
  border-radius: var(--pharma-radius-sm);
  margin-bottom: 1.1rem;
  padding: 1rem 1.1rem;
  transition: box-shadow .2s, border .2s;
  box-shadow: 0 3px 15px rgba(14,165,233,0.09);
  position: relative;
}
.annotation-item:hover {
  border-color: var(--pharma-primary-dark);
  box-shadow: 0 8px 28px rgba(14,165,233,0.14);
}

.annotation-header {
  display: flex;
  align-items: center;
  gap: 0.7rem;
  margin-bottom: 0.6rem;
}

.annotation-type {
  background: linear-gradient(90deg, var(--pharma-primary), var(--pharma-accent) 90%);
  color: #fff;
  border-radius: 999px;
  font-size: 0.97rem;
  font-weight: 600;
  padding: 0.24rem 1.05rem;
}

.annotation-confidence {
  background: #bae6fd;
  color: var(--pharma-primary-dark);
  border-radius: 9px;
  font-size: 0.88rem;
  font-weight: 600;
  padding: 0.19rem 0.7rem;
}

.delete-annotation {
  background: none;
  border: none;
  color: var(--pharma-error);
  cursor: pointer;
  padding: 0.3rem 0.7rem;
  border-radius: 7px;
  transition: background .13s;
  margin-left: auto;
}
.delete-annotation:hover { background: #ffe4e6; }

.annotation-text {
  font-style: italic;
  color: var(--pharma-primary-dark);
  font-size: 1.02rem;
  margin-bottom: 0.3rem;
}

.annotation-reasoning {
  font-size: 0.94rem;
  color: var(--pharma-accent);
  display: flex;
  align-items: center;
  gap: 0.29rem;
}

/* RLHF/AI Generated */
.ai-generated .annotation-type {
  background: linear-gradient(90deg, #f59e0b, #fbbf24 80%);
  color: #fff;
}
.rlhf-indicator {
  margin-top: 0.6rem;
  color: var(--pharma-warn);
  font-weight: 700;
  font-size: 0.98rem;
  display: flex;
  align-items: center;
  gap: 0.3rem;
}

/* Learning Dashboard Widget */
.learning-dashboard-widget {
  background: linear-gradient(90deg, var(--pharma-primary), var(--pharma-accent));
  color: #fff;
  padding: 1.25rem 2rem;
  border-radius: var(--pharma-radius);
  box-shadow: var(--pharma-shadow);
  margin-bottom: 2rem;
  border: none;
  font-size: 1.08rem;
}

.learning-dashboard-widget h4 { color: #fff; font-weight: 700; margin-top: 0; }

.metric {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  margin: 0.35rem 0;
}
.metric-label { font-weight: 600; opacity: 0.87; }
.metric-value { font-size: 1.07rem; font-weight: 700; }
.performance-indicator { font-size: 1.18rem; margin-left: 0.5rem; }
.learning-explanation { font-size: 0.88rem; opacity: 0.89; margin-top: 0.4rem; }

/* Validation Success */
.validation-success {
  background: linear-gradient(90deg, #10b981, #38bdf8);
  color: #fff;
  padding: 1rem 1.6rem;
  border-radius: 14px;
  box-shadow: 0 2px 18px rgba(16,185,129,0.13);
  margin-bottom: 1.2rem;
  display: flex;
  align-items: center;
  gap: 1.2rem;
  transition: opacity 0.5s;
}

/* Modal (boost appearance) */
.modal-content {
  background: #fff;
  border-radius: var(--pharma-radius-sm);
  box-shadow: 0 8px 40px rgba(14,165,233,0.23);
  border: none;
}
.modal-header, .modal-footer {
  background: #f1f5f9;
  border: none;
  border-radius: 12px 12px 0 0;
}
.modal-title { color: var(--pharma-primary-dark); font-weight: 600; }
.btn-close { color: var(--pharma-text-soft); }
.btn-primary {
  background: var(--pharma-primary-dark);
  color: #fff;
  border-radius: 10px;
  border: none;
  font-weight: 700;
  padding: 0.48rem 1.4rem;
  transition: var(--pharma-transition);
}
.btn-primary:hover { background: var(--pharma-primary); color: #fff; }

/* Responsive pour la nouvelle disposition */
@media (max-width: 900px) {
  .main-content { max-width: 99vw; }
  .annotation-header, .text-content-card, .annotations-list, .learning-dashboard-widget, .annotation-types-panel, .page-navigation, .regulatory-analysis-panel {
    padding: 1.1rem 0.8rem !important;
  }

  .actions-container {
    grid-template-columns: 1fr;
    gap: 1rem;
  }

  .buttons-row {
    flex-direction: column;
  }

  .buttons-row .btn-groq,
  .buttons-row .btn-validate,
  .buttons-row .btn-expert {
    font-size: 0.9rem !important;
    padding: 0.7rem 1rem !important;
    min-width: 100%;
  }

  .json-action-pair {
    flex-direction: column;
    gap: 0.8rem;
  }

  .json-action-pair .btn-json-page,
  .json-action-pair .btn-json-document {
    font-size: 0.9rem !important;
    padding: 0.7rem 1rem !important;
    min-width: 100%;
  }

  .btn-view-json-page,
  .btn-view-json-global {
    width: 40px;
    height: 40px;
    font-size: 1rem;
  }
}
.ghost-annotation {
    opacity: 0.6;
    border-color: #f59e0b !important;
}

.ghost-annotation:hover {
    opacity: 1;
    border-color: #f59e0b !important;
}

@media (max-width: 700px) {
  .annotation-header, .annotation-types-panel, .text-content-card, .annotations-list, .learning-dashboard-widget, .regulatory-analysis-panel {
    flex-direction: column !important;
    gap: 1rem !important;
  }

  .page-navigation {
    flex-direction: column;
    align-items: stretch;
  }

  .page-controls {
    justify-content: space-between;
    margin-bottom: 1rem;
  }

  .header-actions { width: 100%; }
  .regulatory-stats { flex-direction: column; }

  .action-group {
    padding: 1rem;
  }

  .group-title {
    font-size: 0.85rem;
  }
}

/* Animations */
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(40px);}
  to   { opacity: 1; transform: translateY(0);}
}

/* Styles pour le bouton d'&eacute;dition */
.edit-annotation {
  background: none;
  border: none;
  color: var(--pharma-primary);
  cursor: pointer;
  padding: 0.3rem 0.7rem;
  border-radius: 7px;
  transition: background .13s;
  margin-right: 0.5rem;
}

.edit-annotation:hover {
  background: #e0f2fe;
  color: var(--pharma-primary-dark);
}

/* Indicateur de modification humaine */
.human-modified-indicator {
  font-size: 0.85rem;
  color: var(--pharma-accent);
  display: flex;
  align-items: center;
  gap: 0.3rem;
  margin-top: 0.5rem;
  padding: 0.3rem 0.6rem;
  background: #d1fae5;
  border-radius: 6px;
  border-left: 3px solid var(--pharma-accent);
}

/* Styles pour le modal d'&eacute;dition */
.modal-lg {
  max-width: 800px;
}

.annotation-info-panel {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Am&eacute;lioration des champs du formulaire d'&eacute;dition */
#edit-selected-text {
  font-family: 'Courier New', monospace;
  border: 2px solid var(--pharma-border);
  transition: border-color 0.3s ease;
}

#edit-selected-text:focus {
  border-color: var(--pharma-primary);
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
}

#edit-annotation-type {
  border: 2px solid var(--pharma-border);
  transition: border-color 0.3s ease;
}

#edit-annotation-type:focus {
  border-color: var(--pharma-primary);
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
}

/* Style pour les champs de position */
#edit-start-pos, #edit-end-pos {
  background-color: #f8f9fa;
  color: #6c757d;
}

/* Am&eacute;lioration du panel d'information */
.annotation-meta > div {
  margin-bottom: 0.5rem;
  padding-bottom: 0.3rem;
}

.annotation-meta > div:not(:last-child) {
  border-bottom: 1px solid #e9ecef;
}

/* Animation pour le modal */
.modal.fade .modal-dialog {
  transition: transform 0.3s ease-out;
  transform: translate(0, -50px);
}

.modal.show .modal-dialog {
  transform: none;
}

/* Style pour les boutons du footer du modal */
.modal-footer .btn {
  min-width: 120px;
  font-weight: 600;
}

.modal-footer .btn-primary {
  background: linear-gradient(90deg, var(--pharma-primary), var(--pharma-accent));
  border: none;
}

.modal-footer .btn-primary:hover {
  background: linear-gradient(90deg, var(--pharma-accent), var(--pharma-primary));
}

/* Prodigy-like Toolbar Styles */
.toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  margin-bottom: 1rem;
  align-items: center;
}

.label-btn {
  border: none;
  padding: 8px 16px;
  border-radius: 8px;
  color: #fff;
  font-weight: 600;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.label-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.label-btn.active {
  transform: scale(1.05);
  box-shadow: 0 0 0 3px rgba(0,0,0,0.3);
  border: 2px solid #fff;
}

/* Inline annotation styles - Version corrig&eacute;e pour pr&eacute;server l'apparence du texte */
.inline-annotation {
  display: inline;
  border-radius: 2px;
  padding: 1px 3px;
  margin: 0;
  cursor: pointer;
  font-weight: inherit;
  font-size: inherit;
  font-family: inherit;
  position: relative;
  transition: background-color 0.2s ease;
  line-height: inherit;
  vertical-align: baseline;
  text-decoration: none;
  /* Supprim&eacute; opacity qui rendait le texte flou */
  /* Supprim&eacute; border-bottom qui d&eacute;formait l'apparence */
}

.inline-annotation:hover {
  /* Supprim&eacute; les transformations qui d&eacute;formaient le texte */
  background-color: rgba(0,0,0,0.05);
}

/* Style unifi&eacute; pour toutes les annotations - VITE les duplications */
.inline-annotation {
  display: inline !important;
  padding: 2px 4px;
  margin: 0 1px;
  border-radius: 3px;
  cursor: pointer;
  font-weight: inherit;
  font-family: inherit;
  font-size: inherit;
  position: relative;
  line-height: inherit;
  white-space: nowrap;
  transition: background-color 0.2s ease;
  vertical-align: baseline;
  text-decoration: none;
}

/* Style sp&eacute;cifique pour la zone de texte brut */
.text-content .inline-annotation {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 6px;
  margin: 0 2px;
  border-radius: 3px;
  background-color: inherit;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  border: none;
}

.text-content .inline-annotation:hover {
  box-shadow: 0 2px 4px rgba(0,0,0,0.15);
}

/* Preserve document structure during annotation - Version corrig&eacute;e */
.structured-content-body .inline-annotation {
  display: inline !important; /* Force inline flow */
  padding: 1px 2px !important; /* Minimal padding */
  margin: 0 !important; /* No margin shifts */
  line-height: inherit !important; /* Match surrounding text */
  vertical-align: baseline !important; /* No vertical shifts */
  font-family: inherit !important; /* Preserve font */
  font-size: inherit !important; /* Preserve size */
  font-weight: inherit !important; /* Preserve weight */
  color: inherit !important; /* Preserve text color */
  text-decoration: none !important; /* No underlines */
  position: relative;
  z-index: 1;
  border-radius: 2px;
  transition: background-color 0.2s ease;
}

.structured-content-body .inline-annotation:hover {
  background-color: rgba(37, 99, 235, 0.15) !important;
}

/* Style sp&eacute;cifique pour les labels dans le contenu structur&eacute; - Version am&eacute;lior&eacute;e */
.structured-content-body .inline-annotation .ann-label {
  display: none;
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.65rem;
  padding: 2px 6px;
  background: rgba(0,0,0,0.8);
  color: white;
  border-radius: 4px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 1000;
  line-height: normal;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.structured-content-body .inline-annotation:hover .ann-label {
  display: block;
  opacity: 1;
}

/* Style pour les annotations avec survol visible */
.inline-annotation:hover {
  background-color: rgba(59, 130, 246, 0.2) !important;
  transition: background-color 0.2s ease;
}




/* Style sp&eacute;cifique pour les labels dans le texte brut */
.text-content .inline-annotation .ann-label {
  display: inline-block;
  margin: 0;
  padding: 0 4px;
  background: rgba(0,0,0,0.6);
  border-radius: 3px;
  font-size: 0.75rem;
  position: static;
  transform: none;
  vertical-align: baseline;
}



/* Ajuster l'espacement vertical */
.structured-content-body p + p {
  margin-top: 1em;
}

/* Am&eacute;lioration de la lisibilit&eacute; du contenu structur&eacute; */
.structured-content-body {
  line-height: 1.6;
  font-size: 1rem;
  color: #1a1a1a;
  letter-spacing: normal;
  word-spacing: normal;
}

.structured-content-body p {
  margin: 0.7em 0;
}


/* Am&eacute;lioration de la lisibilit&eacute; du contenu structur&eacute; */
.structured-content-body {
  line-height: 1.8;
  font-size: 1rem;
  color: #1a1a1a;
  letter-spacing: 0.01em;
}

/* Affichage du label au survol */
.inline-annotation:hover .ann-label {
  display: inline-block;
}

.structured-content-body p {
  margin-bottom: 1em;
}




/* Style pour les sections du contenu structur&eacute; */
.structured-content-body h1,
.structured-content-body h2,
.structured-content-body h3,
.structured-content-body h4 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  color: #2d3748;
  font-weight: 600;
}

/* Enhanced text content for better selection */
.text-content {
  user-select: text;
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
}

.content-tabs {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
}

.tab-btn {
    background: var(--pharma-glass);
    border: 1.5px solid var(--pharma-primary);
    color: var(--pharma-primary-dark);
    border-radius: var(--pharma-radius-sm);
    font-size: 0.9rem;
    padding: 0.5rem 1rem;
    font-weight: 500;
    transition: var(--pharma-transition);
    cursor: pointer;
}

.tab-btn.active,
.tab-btn:hover {
    background: var(--pharma-primary);
    color: #fff;
    border-color: var(--pharma-primary-dark);
}

.content-panel {
    animation: fadeInUp 0.3s ease;
}

.content-panel.active {
    display: block;
}

.actions {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    align-items: center;
}

.toggle-content-btn {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    background-color: #f8f9fa;
    cursor: pointer;
    transition: all 0.3s ease;
}

.toggle-content-btn:hover {
    background-color: #e9ecef;
}

.json-syncing {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 20px 40px;
    border-radius: 12px;
    z-index: 99999;
    font-size: 1.1rem;
}

.json-syncing i {
    margin-right: 10px;
}

</style>

<!-- Annotation Header -->
<section class="annotation-header">
  <div class="header-info">
    <h2><i class="fas fa-file-pdf"></i> {{ document.file.name|basename }}</h2>
    <div class="document-meta">
      <span class="meta-item">
        <i class="fas fa-user"></i>
        {{ document.owner.username }}
      </span>
      <span class="meta-item">
        <i class="fas fa-file-alt"></i>
        Page {{ current_page.page_number }} / {{ total_pages }}
      </span>
      <span class="meta-item">
        <i class="fas fa-calendar"></i>
        {{ document.validated_at|date:"d/m/Y" }}
      </span>
    </div>
  </div>

    <div class="header-actions">
      <button class="nav-btn nav-btn-icon me-2" onclick="viewOriginalDocument({{ document.id }})" title="Voir le document original">
        <i class="fas fa-eye"></i>
      </button>
      <a href="{% url 'rawdocs:annotation_dashboard' %}" class="nav-btn nav-btn-icon" title="Retour au dashboard">
        <i class="fas fa-arrow-left"></i>
      </a>
    </div>
</section>

<!-- NOUVELLE SECTION: Analyse R&eacute;glementaire Panel -->
<section class="regulatory-analysis-panel">
  <h3><i class="fas fa-balance-scale"></i> Analyse R&eacute;glementaire du Document</h3>
  <p class="instructions">Analysez automatiquement le contenu r&eacute;glementaire de chaque page et du document complet</p>

  <!-- Statistiques r&eacute;glementaires -->
  <div class="regulatory-stats">
    <div class="regulatory-stat">
      <span class="regulatory-stat-value">{{ regulatory_stats.analyzed_pages }}</span>
      <span class="regulatory-stat-label">Pages analys&eacute;es</span>
    </div>
    <div class="regulatory-stat">
      <span class="regulatory-stat-value">{{ regulatory_stats.completion_percentage }}%</span>
      <span class="regulatory-stat-label">Progression</span>
    </div>
    <div class="regulatory-stat">
      <span class="regulatory-stat-value">{{ regulatory_stats.high_importance_pages }}</span>
      <span class="regulatory-stat-label">Pages critiques</span>
    </div>
    <div class="regulatory-stat">
      <span class="regulatory-stat-value">{% if global_analysis %}{{ global_analysis.global_regulatory_score }}{% else %}0{% endif %}</span>
      <span class="regulatory-stat-label">Score global</span>
    </div>
  </div>

  <!-- Barre de progression -->
  <div class="regulatory-progress">
    <div class="progress-bar-regulatory" style="width: {{ regulatory_stats.completion_percentage }}%"></div>
  </div>

  <!-- Boutons d'action r&eacute;glementaire -->
  <div class="regulatory-actions" style="display: flex; gap: 1rem; align-items: center;">
    <button id="analyze-page-regulatory-btn" class="btn-regulatory" onclick="analyzePageRegulatory()">
      <i class="fas fa-gavel"></i> Analyser cette Page
    </button>

    <button id="analyze-document-regulatory-btn" class="btn-regulatory" onclick="analyzeDocumentRegulatory()">
      <i class="fas fa-book-open"></i> Analyser tout le Document
    </button>

    <div id="regulatory-loading" class="regulatory-loading" style="display: none;">
      <i class="fas fa-spinner fa-spin"></i> Analyse r&eacute;glementaire en cours...
    </div>
  </div>

  <!-- R&eacute;sum&eacute; global du document si disponible -->
  {% if global_analysis %}
  <div class="document-global-summary" style="margin-top: 1.5rem; padding: 1rem; background: var(--pharma-bg-card); border-radius: 8px; border: 1px solid var(--pharma-border);">
    <h4 style="color: var(--pharma-primary-dark); margin-bottom: 0.8rem;">
      <i class="fas fa-file-contract"></i> R&eacute;sum&eacute; R&eacute;glementaire Global
    </h4>
    <p style="margin-bottom: 1rem; line-height: 1.6;">{{ global_analysis.global_summary }}</p>

    {% if global_analysis.consolidated_analysis.main_regulatory_themes %}
    <div class="regulatory-themes" style="margin-top: 1rem;">
      <strong style="color: var(--pharma-primary-dark);">Th&egrave;mes principaux:</strong>
      <ul style="margin-top: 0.5rem; padding-left: 1.2rem;">
        {% for theme in global_analysis.consolidated_analysis.main_regulatory_themes %}
        <li style="margin-bottom: 0.3rem;">{{ theme }}</li>
        {% endfor %}
      </ul>
    </div>
    {% endif %}
  </div>
  {% endif %}
</section>

<!-- SPARATEUR VISUEL CLAIR -->
<div style="
  margin: 3rem 0;
  height: 60px;
  background: linear-gradient(135deg, rgba(14,165,233,0.1) 0%, rgba(16,185,129,0.1) 50%, rgba(14,165,233,0.1) 100%);
  border-radius: 16px;
  border: 2px solid rgba(14,165,233,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
">
  <div style="
    background: white;
    padding: 8px 20px;
    border-radius: 25px;
    border: 1px solid rgba(14,165,233,0.3);
    box-shadow: 0 4px 12px rgba(14,165,233,0.1);
    font-weight: 600;
    color: var(--pharma-primary-dark);
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  ">
    <span>?</span>
    <span>Analyse R&eacute;glementaire</span>
    <span style="margin: 0 8px;"></span>
    <span></span>
    <span>Annotation</span>
  </div>
</div>

<!-- Prodigy-like Annotation Toolbar -->
<section class="annotation-types-panel">
  <h3>Types d'Annotation</h3>
  <p class="instructions">Cliquez sur un type, puis surlignez le texte dans le document</p>

  <div class="toolbar" id="label-toolbar">
    {% comment %}
    Les types de base ne sont charg&eacute;s que si Mistral n'a pas encore analys&eacute; ce document.
    Une fois que Mistral a propos&eacute; ses types, ils remplacent compl&egrave;tement les types de base.
    {% endcomment %}
    {% if not document.mistral_analyzed %}
      {% for ann_type in annotation_types %}
      <button class="label-btn"
        data-id="{{ ann_type.id }}"
        data-name="{{ ann_type.name }}"
        data-color="{{ ann_type.color }}"
        style="background: {{ ann_type.color }}">
        {{ ann_type.display_name }}
      </button>
      {% endfor %}
    {% endif %}

    <button class="annotation-type-btn-add" data-bs-toggle="modal" data-bs-target="#addAnnotationTypeModal" type="button">
      <i class="fas fa-plus"></i> Add Custom Type
    </button>
    <button id="clear-annotations-btn" class="label-btn" style="background:#6b7280;color:white;">
       Clear All
    </button>
  </div>

  <!-- Modal pour ajouter un type d'annotation -->
  <div class="modal fade" id="addAnnotationTypeModal" tabindex="-1" aria-labelledby="addAnnotationTypeModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="addAnnotationTypeModalLabel">Ajouter un type d'annotation</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="new-annotation-display-name" class="form-label">Nom d'affichage</label>
            <input type="text" class="form-control" id="new-annotation-display-name" required>
          </div>
          <div class="mb-3">
            <label for="new-annotation-name" class="form-label">Nom technique</label>
            <input type="text" class="form-control" id="new-annotation-name" readonly>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
          <button type="button" class="btn btn-primary" onclick="createAnnotationType()">Cr&eacute;er</button>
        </div>
      </div>
    </div>
  </div>

  <div id="context-menu" class="context-menu hidden">
    <button class="context-menu-item danger" onclick="deleteAnnotationTypeFromMenu()">
        <i class="fas fa-trash"></i> Delete Annotation Type
    </button>
    <button class="context-menu-item" onclick="hideContextMenu()">
        <i class="fas fa-times"></i> Cancel
    </button>
  </div>
</section>

<section class="page-navigation">
  <!-- Navigation des pages -->
  <div class="page-controls">
    {% if current_page.page_number > 1 %}
      <a href="?page={{ current_page.page_number|add:'-1' }}" class="nav-btn nav-btn-icon" title="Page pr&eacute;c&eacute;dente">
        <i class="fas fa-angle-left"></i>
      </a>
    {% endif %}

    <div class="page-selector">
      <select id="page-select" onchange="goToPage(this.value)">
        {% for page in pages %}
        <option value="{{ page.page_number }}"
                {% if page.page_number == current_page.page_number %}selected{% endif %}>
          Page {{ page.page_number }}
          {% if page.is_validated_by_human %}{% elif page.is_annotated %}{% endif %}
          {% if page.is_regulatory_analyzed %}?{% endif %}
        </option>
        {% endfor %}
      </select>
    </div>

    {% if current_page.page_number < total_pages %}
      <a href="?page={{ current_page.page_number|add:'1' }}" class="nav-btn nav-btn-icon" title="Page suivante">
        <i class="fas fa-angle-right"></i>
      </a>
    {% endif %}
  </div>

  <!-- Actions organis&eacute;es par cat&eacute;gories -->
  <div class="actions-container">
    <!-- Groupe 1: Actions IA et Validation -->
    <div class="action-group">
      <h4 class="group-title">IA & Validation</h4>
          <div class="buttons-row">
            <button id="groq-annotate-btn" class="btn-groq" onclick="annotateWithGroq()">
              <i class="fas fa-rocket"></i> Annotation AI (Page)
            </button>

            <button id="groq-annotate-all-btn" class="btn-groq" onclick="annotateWithGroqAll()">
              <i class="fas fa-rocket"></i> Annotation AI (Document)
            </button>
            <button onclick="annotateWithLocalLLM({{ current_page.id }})" class="btn-local-llm" 
                    style="background: #10b981; margin-left: 10px;">
                <i class="fas fa-shield-alt"></i> Annotation 100% PrivÃ©e (Local)
            </button>


        <button id="validate-page-btn" class="btn-validate" onclick="validatePage()"
                {% if current_page.is_validated_by_human %}disabled{% endif %}>
          <i class="fas fa-graduation-cap"></i>
          {% if current_page.is_validated_by_human %}Page Valid&eacute;e{% else %}Validate Page{% endif %}
        </button>
      </div>
    </div>

    <!-- Groupe 2: R&eacute;vision Expert -->
    <div class="action-group">
      <h4 class="group-title">R&eacute;vision Expert</h4>
      <div class="buttons-row">
        {% if not document.is_ready_for_expert %}
          <button id="submit-document-expert-btn" class="btn-expert" onclick="submitDocumentForExpert()">
            <i class="fas fa-user-graduate"></i>
            Soumission &agrave; l'Expert
          </button>
        {% else %}
          <button class="btn btn-success" disabled>
            <i class="fas fa-check-circle"></i>
            Document Soumis
          </button>
        {% endif %}
      </div>
    </div>

    <!-- Indicateurs de chargement -->
    <div class="loading-indicators">
      <div id="ai-loading" class="ai-loading" style="display: none;">
        <i class="fas fa-spinner fa-spin"></i> IA en cours...
      </div>

      <div id="learning-progress" class="learning-progress" style="display: none;">
        <i class="fas fa-brain"></i> IA en apprentissage...
      </div>

      <div id="json-loading" class="json-loading" style="display: none;">
        <i class="fas fa-spinner fa-spin"></i> G&eacute;n&eacute;ration JSON...
      </div>
    </div>
  </div>
</section>

<!-- Learning Dashboard Widget (identique) -->
<section class="learning-dashboard-widget" id="learning-widget" style="display: none;"></section>

<!-- NOUVELLE SECTION: Analyse R&eacute;glementaire de la Page Courante -->
{% if current_page.is_regulatory_analyzed %}
<section class="page-regulatory-analysis">
  <h3 style="color: var(--pharma-info); margin-bottom: 1rem;">
    <i class="fas fa-gavel"></i>
    Analyse R&eacute;glementaire - Page {{ current_page.page_number }}
    <span class="importance-score {% if current_page.regulatory_importance_score >= 90 %}critical{% elif current_page.regulatory_importance_score >= 70 %}high{% elif current_page.regulatory_importance_score >= 50 %}medium{% else %}low{% endif %}">
      <i class="fas fa-chart-line"></i>
      Score: {{ current_page.regulatory_importance_score }}/100
    </span>
  </h3>

  <!-- R&eacute;sum&eacute; de la page -->
  {% if page_summary %}
  <div class="page-summary" style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
    <h4 style="color: var(--pharma-info); margin-bottom: 0.5rem;">
      <i class="fas fa-file-text"></i> R&eacute;sum&eacute; de la Page
    </h4>
    <p style="margin: 0; line-height: 1.6;">{{ page_summary }}</p>
  </div>
  {% endif %}

  <!-- Points cl&eacute;s r&eacute;glementaires -->
  {% if page_analysis.key_regulatory_points %}
  <div class="key-points-list">
    <h4 style="color: var(--pharma-primary-dark); margin-bottom: 0.8rem;">
      <i class="fas fa-list-ul"></i> Points Cl&eacute;s R&eacute;glementaires
    </h4>
    {% for point in page_analysis.key_regulatory_points %}
    <div class="key-point">{{ point }}</div>
    {% endfor %}
  </div>
  {% endif %}

  <!-- Obligations r&eacute;glementaires -->
  {% if page_analysis.regulatory_obligations %}
  <div class="regulatory-obligations">
    <h4 style="color: var(--pharma-warn); margin-bottom: 0.8rem;">
      <i class="fas fa-exclamation-triangle"></i> Obligations R&eacute;glementaires
    </h4>
    {% for obligation in page_analysis.regulatory_obligations %}
    <div class="obligation-item obligation-severity {{ obligation.severity }}">
      <strong>{{ obligation.obligation }}</strong>
      {% if obligation.authority %}
      <div style="margin-top: 0.3rem; font-size: 0.9rem; color: var(--pharma-text-soft);">
        <i class="fas fa-building"></i> {{ obligation.authority }}
      </div>
      {% endif %}
      {% if obligation.deadline %}
      <div style="margin-top: 0.3rem; font-size: 0.9rem; color: var(--pharma-warn);">
        <i class="fas fa-clock"></i> {{ obligation.deadline }}
      </div>
      {% endif %}
    </div>
    {% endfor %}
  </div>
  {% endif %}

  <!-- D&eacute;lais critiques -->
  {% if page_analysis.critical_deadlines %}
  <div class="deadlines-list">
    <h4 style="color: var(--pharma-error); margin-bottom: 0.8rem;">
      <i class="fas fa-hourglass-half"></i> D&eacute;lais Critiques
    </h4>
    {% for deadline in page_analysis.critical_deadlines %}
    <div class="deadline-item">
      <div>
        <strong>{{ deadline.deadline }}</strong>
        {% if deadline.trigger_event %}
        <div style="font-size: 0.9rem; color: var(--pharma-text-soft);">
          D&eacute;clencheur: {{ deadline.trigger_event }}
        </div>
        {% endif %}
      </div>
      <span class="deadline-timeframe">{{ deadline.timeframe }}</span>
    </div>
    {% endfor %}
  </div>
  {% endif %}

  <!-- Autorit&eacute;s mentionn&eacute;es -->
  {% if page_analysis.authorities_mentioned %}
  <div class="authorities-list">
    <h4 style="color: var(--pharma-primary-dark); margin-bottom: 0.8rem;">
      <i class="fas fa-university"></i> Autorit&eacute;s R&eacute;glementaires
    </h4>
    {% for authority in page_analysis.authorities_mentioned %}
    <span class="authority-tag">{{ authority.name }}</span>
    {% endfor %}
  </div>
  {% endif %}

  <!-- Documents requis -->
  {% if page_analysis.documents_required %}
  <div class="documents-required" style="margin-top: 1rem;">
    <h4 style="color: var(--pharma-accent); margin-bottom: 0.8rem;">
      <i class="fas fa-folder-open"></i> Documents Requis
    </h4>
    {% for doc in page_analysis.documents_required %}
    <div class="key-point">
      <strong>{{ doc.document }}</strong>
      {% if doc.when %} -  fournir: {{ doc.when }}{% endif %}
      {% if doc.to_whom %} - : {{ doc.to_whom }}{% endif %}
    </div>
    {% endfor %}
  </div>
  {% endif %}
</section>
{% endif %}


<!-- Section de Contenu Structur&eacute; - SPLIT SCREEN VERSION -->
<section class="structured-content-section">
    <div class="structured-content-header">
        <div class="header">
            <div class="main-info">
                <div class="icon-container">
                    <div class="icon-chip">
                        <i class="fas fa-layer-group"></i>
                    </div>
                </div>
                <div class="title-section">
                    <h3>Contenu Structur&eacute; - Vue Annotateur & Expert</h3>
                    <div class="details">
                        <span class="meta-badge info">
                            <i class="fas fa-file-alt"></i> Page {{ current_page.page_number }}
                        </span>
                        <span class="meta-badge warning">
                            <i class="fas fa-columns"></i> Vue Divis&eacute;e
                        </span>
                        <span class="meta-badge success">
                            <i class="fas fa-sync-alt"></i> Temps R&eacute;el
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Split Screen Container -->
    <div class="split-screen-container">
        <!-- LEFT PANEL: Your Working Area -->
        <div class="left-panel">
            <div class="panel-header">
                <div class="panel-title">
                    <i class="fas fa-edit"></i>
                    Zone de Travail
                    <span class="panel-badge badge-editable">&Eacute;ditable</span>
                </div>

            </div>
            <div class="panel-body" id="left-panel-body">
                <div class="structured-content-body" id="structured-annotation-area" data-page-id="{{ current_page.id }}">
                    {% if document.structured_html %}
                        <div class="non-editable-content" id="all-pages-content">
                            {{ document.structured_html|safe }}
                        </div>
                    {% else %}
                        <div class="empty-state">
                            <i class="far fa-file"></i>
                            <p>Contenu structur&eacute; non disponible.</p>
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: JSON Preview for Expert -->
        <div class="right-panel">
            <div class="panel-header">
                <div class="panel-title">
                    <i class="fas fa-file-code"></i>
                    Aper&ccedil;u JSON - Mode Simple
                </div>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <button class="btn btn-sm" onclick="toggleJSONMode()" title="Mode avanc&eacute;" style="padding: 0.5rem 0.75rem; background: rgba(255,255,255,0.2); border: none; border-radius: 8px; cursor: pointer; color: white;">
                        <i class="fas fa-code"></i> Mode Code
                    </button>
                    <button class="btn btn-sm" onclick="copyJSONToClipboard()" title="Copier" style="padding: 0.5rem 0.75rem; background: rgba(59,130,246,0.2); border: none; border-radius: 8px; cursor: pointer; color: white;">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>

            <div class="panel-body" id="right-panel-body" style="background: #0f172a; color: #e2e8f0; padding: 1rem;">

                <!-- Tabs -->
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 0.5rem;">
                    <button class="json-tab-btn active" onclick="switchJSONTab('page')" id="page-json-tab">
                        <i class="fas fa-file"></i> Page {{ current_page.page_number }}
                    </button>
                    <button class="json-tab-btn" onclick="switchJSONTab('document')" id="document-json-tab">
                        <i class="fas fa-book"></i> Document
                    </button>
                </div>

                <!-- Page JSON Content - VISUAL MODE -->
                <div id="page-json-content" class="json-content">
                    <div style="background: rgba(16,185,129,0.1); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.75rem; border-left: 3px solid #10b981;">
                        <div style="font-size: 0.85rem; color: #10b981; font-weight: 600;">
                             Page {{ current_page.page_number }} / {{ document.total_pages }}
                        </div>
                        <div style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">
                            <span id="page-annotations-count">0</span> annotations
                        </div>
                    </div>

                    <!-- VISUAL EDITOR MODE (default) -->
                    <div id="visual-json-editor" style="display: block;">
                        <div id="visual-annotations-list" style="max-height: 50vh; overflow-y: auto;">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>

                    <!-- CODE MODE (hidden by default) -->
                    <pre id="page-json-display" style="display: none; background: #1e293b; padding: 1rem; border-radius: 6px; overflow-x: auto; max-height: 50vh; font-size: 0.8rem; line-height: 1.5; color: #e2e8f0;">Chargement...</pre>
                </div>

                <!-- Document JSON Content -->
                <div id="document-json-content" class="json-content" style="display: none;">
                    <div style="background: rgba(59,130,246,0.1); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.75rem; border-left: 3px solid #3b82f6;">
                        <div style="font-size: 0.85rem; color: #3b82f6; font-weight: 600;">
                             {{ document.title|truncatewords:8 }}
                        </div>
                        <div style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">
                            <span id="doc-total-annotations">0</span> annotations  <span id="doc-total-pages">{{ document.total_pages }}</span> pages
                        </div>
                    </div>
                    <pre id="document-json-display" style="background: #1e293b; padding: 1rem; border-radius: 6px; overflow-x: auto; max-height: 50vh; font-size: 0.8rem; line-height: 1.5; color: #e2e8f0;">Chargement...</pre>
                </div>
            </div>
        </div>
    </div>
</section>



<!-- Hidden raw text container preserved for downstream scripts -->
<div id="page-text" data-page-id="{{ current_page.id }}" style="display: none;">
  {{ page_text }}
</div>

<style>

/* Styles pour l'en-t&ecirc;te de la zone d'annotation principale */
.annotation-main-header {
  background: linear-gradient(135deg, var(--pharma-accent, #16a34a) 0%, var(--pharma-info, #38bdf8) 40%, var(--pharma-primary, #3b82f6) 100%);
  border-radius: 20px;
  padding: 24px;
  color: #fff;
  position: relative;
  overflow: hidden;
  margin-bottom: 20px;
  box-shadow: var(--pharma-shadow);
}

.annotation-main-header::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    radial-gradient(circle at 20% 50%, rgba(255,255,255,.1) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(255,255,255,.08) 0%, transparent 50%),
    radial-gradient(circle at 40% 80%, rgba(255,255,255,.06) 0%, transparent 50%);
  animation: float 20s ease-in-out infinite;
  pointer-events: none;
}

.main-content-container {
  transition: all 0.3s ease;
}

.main-content-container.collapsed {
  display: none;
}

/* Styles pour les badges de statut */
.meta-badge.success {
  background: rgba(34,197,94,0.15);
  border-color: rgba(34,197,94,0.3);
}

.meta-badge.warning {
  background: rgba(251,191,36,0.15);
  border-color: rgba(251,191,36,0.3);
}

.meta-badge.danger {
  background: rgba(239,68,68,0.15);
  border-color: rgba(239,68,68,0.3);
}

.meta-badge.primary {
  background: rgba(59,130,246,0.15);
  border-color: rgba(59,130,246,0.3);
}

/* Styles am&eacute;lior&eacute;s pour la section structur&eacute;e */
.structured-content-section {
    margin: 3rem 0;
    background: var(--pharma-bg-card);
    border-radius: var(--pharma-radius);
    box-shadow: var(--pharma-shadow);
    animation: fadeInUp 0.6s;
}

.structured-content-header {
    background: linear-gradient(135deg, var(--pharma-primary) 0%, var(--pharma-accent) 100%);
    border: none;
    border-radius: var(--pharma-radius) var(--pharma-radius) 0 0;
    padding: 2rem;
    position: relative;
    color: white;
    overflow: hidden;
}

.structured-content-header.hidden + .structured-content-card {
    display: none;
}

/* Styles communs pour les boutons d'action */
.toggle-content-btn,
.zoom-content-btn {
    background: rgba(255, 255, 255, 0.15);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    padding: 10px 20px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: blur(8px);
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    font-size: 0.9rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* Styles sp&eacute;cifiques pour le bouton de zoom */
.zoom-content-btn {
    margin-right: 10px;
    background: rgba(255, 255, 255, 0.2);
}

.zoom-content-btn.zoomed i {
    transform: rotate(180deg);
}

.zoom-content-btn.zoomed {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
}

.toggle-content-btn:hover {
    background: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
}

.toggle-content-btn:active {
    transform: translateY(0);
}

.toggle-content-btn i {
    font-size: 1.1rem;
    transition: transform 0.3s ease;
}

.toggle-content-btn:hover i {
    transform: scale(1.1);
}

.toggle-content-btn.btn-show {
    background: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 255, 255, 0.4);
}

/* Animations pour le contenu */
@keyframes fadeInDown {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeOutUp {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(-20px);
    }
}

/* Style pour la section quand le contenu est masqu&eacute; */
.structured-content-section.content-hidden {
    margin-bottom: 1rem;
}

.structured-content-card {
    background: var(--pharma-bg-card);
    border: 1.5px solid var(--pharma-info);
    border-top: none;
    border-radius: 0 0 var(--pharma-radius) var(--pharma-radius);
    box-shadow: var(--pharma-shadow);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: top center;
}

.structured-content-card.zoomed {
    margin: 1rem 0;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
    z-index: 100;
    position: relative;
}

/* Style de la scrollbar pour le contenu zoom&eacute; */
.structured-content-card.zoomed::-webkit-scrollbar {
    width: 8px;
}

.structured-content-card.zoomed::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

.structured-content-card.zoomed::-webkit-scrollbar-thumb {
    background: var(--pharma-primary);
    border-radius: 4px;
}

.structured-content-card.zoomed::-webkit-scrollbar-thumb:hover {
    background: var(--pharma-primary-dark);
}

.structured-content-body {
    padding: 0.5rem 1.5rem 1.5rem;
    line-height: 1.8;
    font-size: 1.05rem;
    color: var(--pharma-text);
    cursor: text;
    user-select: text;
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    position: relative;
    background: white;
    min-height: 300px;
    border: 1px solid var(--pharma-border);
    border-radius: 0 0 var(--pharma-radius) var(--pharma-radius);
}



.structured-content-body .ann-label {
    font-size: 0.7rem;
    font-weight: bold;
    margin-left: 4px;
    padding: 2px 6px;
    border-radius: 4px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    white-space: nowrap;
}

/* Rendre le contenu non-&eacute;ditable mais s&eacute;lectionnable */
.non-editable-content {
    pointer-events: auto;
    user-select: text;
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
}

.non-editable-content * {
    pointer-events: auto !important;
    user-select: text !important;
    -webkit-user-select: text !important;
    -moz-user-select: text !important;
    -ms-user-select: text !important;
}

/* Ensure no helper banner is injected before the structured content */
.structured-content-body::before,
.non-editable-content::before {
    content: none !important;
    display: none !important;
}

50% { border-color: var(--pharma-accent); }
    100% { border-color: var(--pharma-info); }
}

/* Styles pour la section de contenu structur&eacute; dans l'annotateur */
.structured-content-section {
    margin-bottom: 3rem;
    animation: fadeInUp 0.6s ease-out;
}

.structured-content-header {
    position: relative;
    overflow: hidden;
    border-radius: 20px;
    padding: 24px;
    color: #fff;
    background: linear-gradient(135deg, var(--pharma-accent, #16a34a) 0%, var(--pharma-info, #38bdf8) 40%, var(--pharma-primary, #3b82f6) 100%);
    box-shadow: var(--pharma-shadow);
    margin-bottom: 20px;
    border: none;
    backdrop-filter: blur(20px);
}

.structured-content-header::before {
    content: '';
    position: absolute;
    inset: 0;
    background:
        radial-gradient(circle at 20% 50%, rgba(255,255,255,.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,.08) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,.06) 0%, transparent 50%);
    animation: float 20s ease-in-out infinite;
    pointer-events: none;
}

@keyframes float {
    0%, 100% { transform: translateY(0px) rotate(0deg); }
    33% { transform: translateY(-10px) rotate(1deg); }
    66% { transform: translateY(5px) rotate(-1deg); }
}

.structured-content-header::after {
    content: '';
    position: absolute;
    top: -2px; left: -2px; right: -2px; bottom: -2px;
    background: linear-gradient(135deg, var(--pharma-accent, #16a34a), var(--pharma-info, #38bdf8), var(--pharma-primary, #3b82f6));
    border-radius: 22px;
    z-index: -1;
    opacity: 0.3;
    filter: blur(8px);
}

.sh-content {
    position: relative;
    z-index: 2;
}

.header {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 20px;
    align-items: flex-start;
    margin-bottom: 16px;
}

.main-info {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    min-width: 0;
}

.icon-container {
    position: relative;
    flex-shrink: 0;
}

.icon-chip {
    width: 60px;
    height: 60px;
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(12px);
    border: 2px solid rgba(255,255,255,0.25);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.icon-chip::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.icon-chip:hover::before {
    transform: translateX(100%);
}

.icon-chip:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 24px rgba(0,0,0,0.15);
}

.icon-chip i {
    font-size: 24px;
    color: #fff;
    z-index: 1;
    position: relative;
}

.title-section {
    min-width: 0;
    flex: 1;
}

.header h3 {
    margin: 0;
    font-size: 1.5rem;
    line-height: 1.2;
    font-weight: 700;
    letter-spacing: -0.02em;
    text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 6px;
    color: #fff;
}

.metadata {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 12px;
    font-size: 0.9rem;
    opacity: 0.95;
}

.metadata p {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 500;
    margin: 0;
}

.metadata p::before {
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    opacity: 0.8;
    font-size: 0.8rem;
}

.metadata p:first-child::before { content: '\f085'; } /* cogs */
.metadata p:nth-child(2)::before { content: '\f017'; } /* clock */
.metadata p:nth-child(3)::before { content: '\f0ad'; } /* wrench */

.actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: flex-end;
    align-items: flex-start;
}

.btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 16px;
    border-radius: 12px;
    text-decoration: none;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-weight: 600;
    font-size: 0.85rem;
    backdrop-filter: blur(12px);
    transition: all 0.3s ease;
    white-space: nowrap;
    cursor: pointer;
}

.btn:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-1px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.15);
    border-color: rgba(255,255,255,0.4);
    color: #fff;
    text-decoration: none;
}

.btn-primary {
    background: rgba(255,255,255,0.2);
    border-color: rgba(255,255,255,0.3);
    position: relative;
    overflow: hidden;
}

.btn-primary::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.btn-primary:hover::before {
    transform: translateX(100%);
}

.btn-primary:hover {
    background: rgba(255,255,255,0.25);
    transform: translateY(-2px);
}

.details {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.meta-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border-radius: 50px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.2);
    font-weight: 600;
    font-size: 0.8rem;
    letter-spacing: 0.3px;
    backdrop-filter: blur(8px);
    transition: all 0.3s ease;
}

.meta-badge:hover {
    background: rgba(255,255,255,0.18);
    transform: translateY(-1px);
}

.meta-badge i {
    opacity: 0.9;
    font-size: 0.75rem;
}

.meta-badge.success {
    background: rgba(34,197,94,0.15);
    border-color: rgba(34,197,94,0.3);
    color: #fff;
}

.meta-badge.warning {
    background: rgba(251,191,36,0.15);
    border-color: rgba(251,191,36,0.3);
    color: #fff;
}

.meta-badge.info {
    background: rgba(59,130,246,0.15);
    border-color: rgba(59,130,246,0.3);
    color: #fff;
}

.structured-content-card {
    background: var(--pharma-bg-card);
    border: 1.5px solid var(--pharma-border);
    border-radius: var(--pharma-radius);
    box-shadow: var(--pharma-shadow);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.structured-content-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, var(--pharma-accent), var(--pharma-info), var(--pharma-primary));
    border-radius: var(--pharma-radius) var(--pharma-radius) 0 0;
}

.structured-content-card:hover {
    box-shadow: 0 10px 25px -3px rgba(0,0,0,0.1);
    transform: translateY(-1px);
}

.structured-content-body {
    padding: 2rem;
    user-select: text;
    -webkit-user-select: text;
    line-height: 1.6;
}

.structured-content-body * {
    pointer-events: auto;
}

.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: #64748b;
}

.empty-state i {
    font-size: 3rem;
    margin-bottom: 16px;
    opacity: 0.5;
}

.empty-state p {
    font-size: 1.1rem;
    margin-bottom: 20px;
}

.empty-state .btn {
    background: linear-gradient(135deg, var(--pharma-primary) 0%, var(--pharma-accent) 100%);
    border: none;
    color: #fff;
    padding: 12px 24px;
}

.empty-state .btn:hover {
    background: linear-gradient(135deg, var(--pharma-accent) 0%, var(--pharma-primary) 100%);
    color: #fff;
    transform: translateY(-2px);
}

/* Animation de collapse/expand */
.structured-content-card.collapsed .structured-content-body {
    display: none;
}

.structured-content-card.collapsed {
    margin-bottom: 1rem;
}

/* Responsive */
@media (max-width: 768px) {
    .structured-content-header {
        padding: 16px;
        border-radius: 16px;
    }

    .header {
        grid-template-columns: 1fr;
        gap: 16px;
    }

    .main-info {
        gap: 12px;
    }

    .icon-chip {
        width: 50px;
        height: 50px;
        border-radius: 12px;
    }

    .icon-chip i {
        font-size: 20px;
    }

    .header h3 {
        font-size: 1.25rem;
    }

    .metadata {
        flex-direction: column;
        gap: 6px;
    }

    .actions {
        justify-content: flex-start;
        gap: 6px;
    }

    .btn {
        padding: 8px 12px;
        font-size: 0.8rem;
    }

    .details {
        gap: 6px;
    }

    .meta-badge {
        padding: 6px 10px;
        font-size: 0.75rem;
    }

    .structured-content-body {
        padding: 1rem;
    }
}

@media (max-width: 480px) {
    .main-info {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
    }

    .actions {
        width: 100%;
    }

    .btn {
        flex: 1;
        justify-content: center;
    }
}

/* Animation de fadeIn */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Ensure structured content sticks flush to top/left */
.structured-content-body {
    padding-top: 0 !important;
    padding-left: 0 !important;
}
.structured-content-body > *:first-child {
    margin-top: 0 !important;
}

.non-editable-content {
    padding-top: 0 !important;
    padding-left: 0 !important;
}

.structured-content-body p:first-child,
.structured-content-body h1:first-child,
.structured-content-body h2:first-child,
.structured-content-body h3:first-child,
.structured-content-body h4:first-child,
.structured-content-body div:first-child {
    margin-top: 0 !important;
}

.text-content {
    padding-top: 0 !important;
    padding-left: 0 !important;
}

.text-content > *:first-child {
    margin-top: 0 !important;
}

</style>

<script>
function toggleMainContent() {
    const container = document.getElementById('main-content-container');
    const btn = document.querySelector('.text-content-card .toggle-content-btn');
    const btnIcon = btn.querySelector('i');
    const btnText = btn.querySelector('span');

    if (container.classList.contains('collapsed')) {
        // Afficher le contenu
        container.classList.remove('collapsed');
        container.style.animation = 'fadeInDown 0.3s ease-out';
        btnIcon.className = 'fas fa-eye-slash';
        btnText.textContent = 'Masquer';
        btn.classList.remove('btn-show');
    } else {
        // Masquer le contenu
        container.style.animation = 'fadeOutUp 0.3s ease-out';
        setTimeout(() => {
            container.classList.add('collapsed');
        }, 280);
        btnIcon.className = 'fas fa-eye';
        btnText.textContent = 'Afficher';
        btn.classList.add('btn-show');
    }
}

// S'assurer que l'animation est d&eacute;finie
if (!document.querySelector('style#animation-styles')) {
    const style = document.createElement('style');
    style.id = 'animation-styles';
    style.textContent = `
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
    `;
    document.head.appendChild(style);
}

// JavaScript pour la gestion du contenu structur&eacute; dans l'annotateur

function toggleStructuredContent() {
    const container = document.getElementById('structured-content-container');
    const toggleText = document.getElementById('toggle-text');
    const icon = document.querySelector('.toggle-structured-btn i');

    if (container.classList.contains('collapsed')) {
        container.classList.remove('collapsed');
        toggleText.textContent = 'Masquer';
        icon.className = 'fas fa-eye';
    } else {
        container.classList.add('collapsed');
        toggleText.textContent = 'Afficher';
        icon.className = 'fas fa-eye-slash';
    }
}

function regenerateStructuredContent() {
    if (!confirm('R&eacute;g&eacute;n&eacute;rer le contenu structur&eacute; ? Cette op&eacute;ration peut prendre quelques minutes.')) {
        return;
    }

    const documentId = {{ document.id }};
    const loading = showStructuredLoadingIndicator('R&eacute;g&eacute;n&eacute;ration en cours...');

    fetch(`/structured/regenerate/${documentId}/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        hideStructuredLoadingIndicator(loading);
        if (data.success) {
            showStructuredSuccess('Contenu structur&eacute; r&eacute;g&eacute;n&eacute;r&eacute; avec succ&egrave;s');
            // Recharger la section structured content
            setTimeout(() => {
                location.reload();
            }, 2000);
        } else {
            alert('Erreur: ' + data.error);
        }
    })
    .catch(error => {
        hideStructuredLoadingIndicator(loading);
        console.error('Erreur r&eacute;g&eacute;n&eacute;ration:', error);
        alert('Erreur lors de la r&eacute;g&eacute;n&eacute;ration du contenu structur&eacute;');
    });
}

function generateStructuredContent() {
    if (!confirm('G&eacute;n&eacute;rer le contenu structur&eacute; ? Cette op&eacute;ration peut prendre quelques minutes.')) {
        return;
    }

    const documentId = {{ document.id }};
    const loading = showStructuredLoadingIndicator('G&eacute;n&eacute;ration en cours...');

    fetch(`/structured/generate/${documentId}/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        hideStructuredLoadingIndicator(loading);
        if (data.success) {
            showStructuredSuccess('Contenu structur&eacute; g&eacute;n&eacute;r&eacute; avec succ&egrave;s');
            // Remplacer le contenu de l'empty state
            const host = document.getElementById('structured-host');
            if (host && data.structured_html) {
                host.innerHTML = data.structured_html;
            }
        } else {
            alert('Erreur: ' + data.error);
        }
    })
    .catch(error => {
        hideStructuredLoadingIndicator(loading);
        console.error('Erreur g&eacute;n&eacute;ration:', error);
        alert('Erreur lors de la g&eacute;n&eacute;ration du contenu structur&eacute;');
    });
}

function showStructuredLoadingIndicator(message) {
    const loading = document.createElement('div');
    loading.className = 'validation-success';
    loading.innerHTML = `
        <i class="fas fa-spinner fa-spin" style="font-size: 1.5rem;"></i>
        <div>
            <strong>${message}</strong>
            <div style="font-size: 0.9rem; opacity: 0.9;">
                Veuillez patienter...
            </div>
        </div>
    `;
    loading.id = 'structured-loading-indicator';

    const section = document.querySelector('.structured-content-section');
    if (section) {
        section.parentNode.insertBefore(loading, section);
    }

    return loading;
}

function hideStructuredLoadingIndicator(loading) {
    if (loading && loading.parentNode) {
        loading.parentNode.removeChild(loading);
    }
}

function showStructuredSuccess(message) {
    const success = document.createElement('div');
    success.className = 'validation-success';
    success.innerHTML = `
        <i class="fas fa-layer-group" style="font-size: 1.5rem;"></i>
        <div>
            <strong> ${message}</strong>
            <div style="font-size: 0.9rem; opacity: 0.9;">
                Le contenu structur&eacute; a &eacute;t&eacute; mis &agrave; jour
            </div>
        </div>
    `;

    const section = document.querySelector('.structured-content-section');
    if (section) {
        section.parentNode.insertBefore(success, section);
        setTimeout(() => success.remove(), 5000);
    }
}


async function annotateWithLocalLLM(pageId) {
    const btn = event.target.closest('button');
    const originalText = btn.innerHTML;
    
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyse locale (GPU)...';
    
    try {
        const response = await fetch(`/annotation/local-llm/${pageId}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        const data = await response.json();
        
        if (data.success) {
            showNotification(
                `âœ… ${data.annotations_created} annotations crÃ©Ã©es (100% privÃ©!)`, 
                'success'
            );
            // Recharger la page pour afficher les annotations
            setTimeout(() => location.reload(), 1000);
        } else {
            showNotification(`âŒ ${data.error || 'Erreur'}`, 'error');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showNotification('âŒ Erreur: ' + error.message, 'error');
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
}
function getCurrentPageNumber() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('page') || '1';
}
// Initialiser l'&eacute;tat collapsed par d&eacute;faut si souhait&eacute;
document.addEventListener('DOMContentLoaded', function() {

});
</script>

<script src="{% static 'rawdocs/js/rlhf_annotation.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
// Combined Prodigy-like + Existing functionality JavaScript
let annotationTypeMap = {};
let selectedAnnotationType = null;
let selectedColor = null;
let currentLabel = null;
let currentEditingAnnotationId = null;
let editModal = null;
let contextMenuTarget = null;

// NEW FUNCTION: Insert annotation at end when text not found
function insertAnnotationAtEnd(annotation, container) {
    const text = annotation.selected_text || annotation.text || '';
    if (isWhitespaceOnly(text)) {
        console.warn('â­ï¸ Skipping whitespace annotation at end:', annotation.id);
        return false;
    }

    console.log(`ðŸ“ Inserting annotation ${annotation.id} at end of document`);

    // Create a special marker paragraph
    const markerP = document.createElement('p');
    markerP.style.cssText = `
        margin-top: 2rem;
        padding: 1rem;
        background: rgba(251,191,36,0.1);
        border-left: 4px solid #f59e0b;
        border-radius: 4px;
    `;

    // Create the annotation span
    const span = document.createElement('span');
    span.className = 'inline-annotation structured-inline-annotation';
    span.dataset.annotationId = annotation.id;
    span.dataset.annotationArea = 'structured';
    span.dataset.annotationRoot = 'true';
    span.dataset.insertedAtEnd = 'true';

    const rgb = hexToRgb(annotation.color || '#ffeb3b');
    const bgColor = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)` : `${annotation.color}33`;

    span.style.cssText = `
        background-color: ${bgColor};
        color: inherit;
        font-family: inherit;
        font-size: inherit;
        font-weight: inherit;
        padding: 2px 4px;
        margin: 0 1px;
        border-radius: 3px;
        cursor: pointer;
        border: 2px dashed #f59e0b;
    `;

    span.textContent = text;
    span.setAttribute('data-original-text', text);

    // Add label with warning
    const label = document.createElement('span');
    label.className = 'ann-label';
    label.style.cssText = `
        font-size: 0.7rem;
        font-weight: bold;
        margin-left: 4px;
        padding: 2px 6px;
        border-radius: 4px;
        background: rgba(251,191,36,0.9);
        color: #000;
        white-space: nowrap;
        display: inline;
        opacity: 1;
    `;
    label.textContent = `${annotation.type_display || 'Entity'} âš ï¸`;
    span.appendChild(label);

    // Add click handler
    span.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();

        const markerParagraph = this.closest('p[data-annotation-marker]');
        if (markerParagraph) {
            markerParagraph.remove();
        } else {
            const originalText = this.getAttribute('data-original-text');
            if (originalText) {
                const textNode = document.createTextNode(originalText);
                this.parentNode.replaceChild(textNode, this);
            }
        }

        deleteAnnotationFromDB(this.dataset.annotationId);
    });

    // Add warning text
    const warningText = document.createTextNode('âš ï¸ Annotation restaurÃ©e (texte non trouvÃ©): ');
    markerP.appendChild(warningText);
    markerP.appendChild(span);
    markerP.dataset.annotationMarker = 'true';

    // Append to end of document
    container.appendChild(markerP);

    console.log(`âœ… Inserted annotation ${annotation.id} at end with warning`);
    return true;
}

function loadAnnotationsInStructuredContent() {
    const structuredArea = document.getElementById('structured-annotation-area');
    if (!structuredArea) {
        console.log('âŒ No structured area found');
        return;
    }

    const previousTop = structuredArea.scrollTop;
    const previousLeft = structuredArea.scrollLeft;

    if (!structuredArea.dataset.originalHtml) {
        const currentPageNumber = {{ current_page.page_number }};
        const allPagesContent = document.getElementById('all-pages-content');

        if (allPagesContent) {
            const allPages = allPagesContent.querySelectorAll('[class*="page"], [id*="page"], section, .page-content');
            if (allPages.length > 0) {
                allPages.forEach((page, index) => {
                    page.style.display = (index === currentPageNumber - 1) ? 'block' : 'none';
                });
            }
        }

        // NOW save the filtered HTML (only current page visible)
        const cleaned = (structuredArea.innerHTML || '').trimStart();
        structuredArea.dataset.originalHtml = cleaned;
        console.log('ðŸ’¾ Saved current page HTML only');
    }

    // Reset to clean HTML before applying annotations
    const cleaned = structuredArea.dataset.originalHtml || '';
    structuredArea.innerHTML = cleaned;
    console.log('ðŸ§¹ Reset to clean HTML');

    const pageId = structuredArea.dataset.pageId;
    if (!pageId) {
        console.log('âŒ No pageId on structured area');
        return;
    }

    console.log('ðŸ“¥ Loading structured annotations for page', pageId);

    fetch(`/annotation/page/${pageId}/`)
        .then(response => response.json())
        .then(data => {
            console.log('ðŸ“¦ RAW API RESPONSE:', {
                success: data.success,
                total: data.annotations?.length || 0,
                first_5_annotations: data.annotations?.slice(0, 5).map(a => ({
                    id: a.id,
                    text: (a.selected_text || '').substring(0, 30),
                    mode: a.mode,
                    page_id: a.page_id
                }))
            });

            console.log('ðŸ“¦ Received annotation data:', data);
            if (!data.success) {
                console.error('âŒ API returned error:', data);
                return;
            }

            if (!data.annotations || data.annotations.length === 0) {
                console.log('â„¹ï¸ No annotations to load');
                return;
            }

            console.log(`ðŸ“Š Processing ${data.annotations.length} annotations`);

            // Filter for structured mode and non-whitespace
            // Filter for structured mode and non-whitespace
            const structuredAnnotations = data.annotations.filter(ann => {
                const annText = ann.selected_text || ann.text || '';
                const hasText = !isWhitespaceOnly(annText);

                if (!hasText) {
                    console.warn('â­ï¸ Skipping whitespace annotation:', ann.id);
                    return false;
                }

                // ACCEPT ALL MODES for backward compatibility
                console.log(`âœ“ Including annotation ${ann.id} (mode: ${ann.mode || 'null'})`);
                return true;
            });

            console.log(`âœ… Found ${structuredAnnotations.length} valid structured annotations`);

            // Sort by position to avoid conflicts
            structuredAnnotations.sort((a, b) => {
                const startA = a.start_pos || 0;
                const startB = b.start_pos || 0;
                return startA - startB;
            });

            let restoredCount = 0;
            let failedCount = 0;

            structuredAnnotations.forEach(annotation => {
                const text = (annotation.selected_text || annotation.text || '').substring(0, 50);
                console.log(`ðŸ”„ Attempting to restore annotation ${annotation.id}: "${text}..."`);

                // Try XPath first if available
                let restored = false;
                if (annotation.start_xpath) {
                    try {
                        restored = restoreAnnotationFromXPath(annotation);
                        if (restored) {
                            console.log(`âœ… XPath success: ${annotation.id}`);
                            restoredCount++;
                            return;
                        }
                    } catch (e) {
                        console.warn(`âš ï¸ XPath failed for ${annotation.id}:`, e.message);
                    }
                }

                // Fallback to text search
                if (!restored) {
                    console.log(`ðŸ” Trying text search for ${annotation.id}`);
                    try {
                        restored = restoreAnnotationByText(annotation, structuredArea);
                        if (restored) {
                            console.log(`âœ… Text search success: ${annotation.id}`);
                            restoredCount++;
                        } else {
                            console.warn(`âŒ Text not found for ${annotation.id} - SKIPPED`);
                            failedCount++;
                        }
                    } catch (e) {
                        console.error(`âŒ Error restoring ${annotation.id}:`, e);
                        console.error(`âŒ Skipping ${annotation.id}`);
                        failedCount++;
                    }
                }
            });

            console.log(`ðŸ“Š Restoration complete: ${restoredCount} restored, ${failedCount} inserted at end`);

            // Clean up
            removeEmptyInlineAnnotations(structuredArea);
            trimLeadingWhitespace(structuredArea);

            // Restore scroll position
            structuredArea.scrollTop = previousTop;
            structuredArea.scrollLeft = previousLeft;

            // Update visual JSON display
            setTimeout(() => {
                loadVisualAnnotations();
            }, 500);
        })
        .catch(error => {
            console.error('âŒ Error loading structured annotations:', error);
        });
}
function collectVisibleTextNodes(container) {
    // CRITICAL FIX: Only collect from VISIBLE page
    let searchArea = container;

    const allPages = container.querySelectorAll('[class*="page"], [id*="page"], section, .page-content');
    if (allPages.length > 0) {
        for (let page of allPages) {
            if (page.style.display !== 'none') {
                searchArea = page;
                console.log('âœ“ Collecting text only from visible page');
                break;
            }
        }
    }

    const textNodes = [];
    const walker = document.createTreeWalker(
        searchArea,  // Changed from 'container' to 'searchArea'
        NodeFilter.SHOW_TEXT,
        {
            acceptNode: function(node) {
                let parent = node.parentNode;

                while (parent) {
                    if (parent.classList && parent.classList.contains('ann-label')) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    // CRITICAL: Reject hidden elements
                    if (parent.style && parent.style.display === 'none') {
                        return NodeFilter.FILTER_REJECT;
                    }
                    if (parent === searchArea) {
                        break;
                    }
                    parent = parent.parentNode;
                }

                return NodeFilter.FILTER_ACCEPT;
            }
        },
        false
    );

    let fullText = '';
    let currentNode;

    while (currentNode = walker.nextNode()) {
        const segment = currentNode.textContent || '';
        const start = fullText.length;
        fullText += segment;
        textNodes.push({
            node: currentNode,
            start,
            end: start + segment.length
        });
    }

    return { textNodes, fullText };
}

function mapDocumentOffsetToNode(textNodes, offset) {
    if (!textNodes.length) {
        return null;
    }

    for (let i = 0; i < textNodes.length; i++) {
        const info = textNodes[i];

        if (offset < info.end) {
            return {
                node: info.node,
                offset: offset - info.start
            };
        }

        if (offset === info.end) {
            if (i + 1 < textNodes.length) {
                return {
                    node: textNodes[i + 1].node,
                    offset: 0
                };
            }

            return {
                node: info.node,
                offset: info.end - info.start
            };
        }
    }

    const lastInfo = textNodes[textNodes.length - 1];
    return {
        node: lastInfo.node,
        offset: lastInfo.end - lastInfo.start
    };
}

function createWhitespaceNormalizedIndex(text) {
    let normalized = '';
    const normalizedToOriginal = [];
    const originalToNormalized = [];
    let lastWasSpace = false;

    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (/\s/.test(char)) {
            if (!lastWasSpace) {
                normalized += ' ';
                normalizedToOriginal.push(i);
                lastWasSpace = true;
            }
            originalToNormalized[i] = normalized.length - 1;
        } else {
            normalized += char;
            normalizedToOriginal.push(i);
            originalToNormalized[i] = normalized.length - 1;
            lastWasSpace = false;
        }
    }

    return { normalized, normalizedToOriginal, originalToNormalized };
}

function createFlexibleIndex(text) {
    let normalized = '';
    const normalizedToOriginal = [];
    const originalToNormalized = new Array(text.length).fill(-1);
    let normalizedIndex = 0;

    const isSkippablePunctuation = char => /[\u2013\u2014\-.,;:'"()\[\]{}!?]/.test(char);

    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const lower = char.toLowerCase();

        if (/\s/.test(char)) {
            originalToNormalized[i] = normalizedIndex - 1;
            continue;
        }

        if (char === '\u00AD') {
            originalToNormalized[i] = normalizedIndex - 1;
            continue;
        }

        if (char === '-' && i + 1 < text.length && /\s/.test(text[i + 1])) {
            originalToNormalized[i] = normalizedIndex - 1;
            continue;
        }

        if (isSkippablePunctuation(char)) {
            originalToNormalized[i] = normalizedIndex - 1;
            continue;
        }

        normalized += lower;
        normalizedToOriginal.push(i);
        originalToNormalized[i] = normalizedIndex;
        normalizedIndex++;
    }

    return { normalized, normalizedToOriginal, originalToNormalized };
}

function findTextRangeAcrossNodes(container, searchText) {
    if (!searchText) {
        return null;
    }

    const { textNodes, fullText } = collectVisibleTextNodes(container);
    // DEBUG: Log what we're searching IN
    console.log('ðŸ“„ Full text preview:', fullText.substring(0, 500));
    console.log('ðŸ“„ Searching for in full text:', searchText);
    console.log('ðŸ“„ Direct indexOf result:', fullText.indexOf(searchText));

    // Try searching with HTML entity decoded
    const div = document.createElement('div');
    div.innerHTML = searchText;
    const decodedSearch = div.textContent;
    console.log('ðŸ“„ Decoded search text:', decodedSearch);
    console.log('ðŸ“„ Decoded indexOf result:', fullText.indexOf(decodedSearch));

    if (!fullText) {
        return null;
    }

    // Case-insensitive search first
    let matchStart = fullText.toLowerCase().indexOf(searchText.toLowerCase());
    if (matchStart !== -1) {
        // Adjust to actual case position
        const beforeMatch = fullText.substring(0, matchStart);
        matchStart = beforeMatch.length;
    }
    let matchEnd = matchStart !== -1 ? matchStart + searchText.length : -1;

    if (matchStart === -1) {
        const sourceIndex = createWhitespaceNormalizedIndex(fullText);
        const targetIndex = createWhitespaceNormalizedIndex(searchText);
        const normalizedIndex = sourceIndex.normalized.indexOf(targetIndex.normalized);

        if (normalizedIndex !== -1) {
            matchStart = sourceIndex.normalizedToOriginal[normalizedIndex];

            while (
                matchStart > 0 &&
                sourceIndex.originalToNormalized[matchStart - 1] === sourceIndex.originalToNormalized[matchStart]
            ) {
                matchStart--;
            }

            const lastNormalizedIndex = normalizedIndex + targetIndex.normalized.length - 1;
            let matchEndCandidate = sourceIndex.normalizedToOriginal[lastNormalizedIndex] + 1;

            while (
                matchEndCandidate < fullText.length &&
                sourceIndex.originalToNormalized[matchEndCandidate] === lastNormalizedIndex
            ) {
                matchEndCandidate++;
            }

            matchEnd = matchEndCandidate;
        }
    }

    if (matchStart === -1 || matchEnd === -1) {
        const sourceIndex = createFlexibleIndex(fullText);
        const targetIndex = createFlexibleIndex(searchText);

        if (targetIndex.normalized) {
            const normalizedIndex = sourceIndex.normalized.indexOf(targetIndex.normalized);

            if (normalizedIndex !== -1) {
                matchStart = sourceIndex.normalizedToOriginal[normalizedIndex];
                const endNormalizedIndex = normalizedIndex + targetIndex.normalized.length - 1;
                const mappedEnd = sourceIndex.normalizedToOriginal[endNormalizedIndex];
                matchEnd = (typeof mappedEnd === 'number') ? mappedEnd + 1 : -1;

                console.log(' Flexible normalization matched text snippet:', fullText.slice(Math.max(0, matchStart - 40), Math.min(fullText.length, matchEnd + 40)));
            }
        }
    }

    if (matchStart === -1 || matchEnd === -1) {
        console.log('âŒ Text genuinely not found after all methods');
        return null;
    }

    const startPosition = mapDocumentOffsetToNode(textNodes, matchStart);
    const endPosition = mapDocumentOffsetToNode(textNodes, matchEnd);

    if (!startPosition || !endPosition) {
        return null;
    }

    return {
        startNode: startPosition.node,
        startOffset: startPosition.offset,
        endNode: endPosition.node,
        endOffset: endPosition.offset,
        matchedText: fullText.slice(matchStart, matchEnd)
    };
}

function restoreAnnotationByText(annotation, container) {
    const rawText = annotation.selected_text || annotation.text || '';
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = rawText;
    const text = tempDiv.textContent.trim();
    console.log('ðŸ” Searching for:', JSON.stringify(text));
    console.log('ðŸ” Text length:', text.length);
    console.log('ðŸ” Char codes:', Array.from(text).map(c => c.charCodeAt(0)));

    const type = annotation.type_display || annotation.type;
    const color = annotation.color || '#ffeb3b';
    const annotationId = annotation.id || `temp-${Date.now()}`;

   // CRITICAL FIX: Only search in VISIBLE content
    const allPages = container.querySelectorAll('[class*="page"], [id*="page"], section, .page-content');
    let visibleContainer = container;

    if (allPages.length > 0) {
        // Find the visible page
        for (let page of allPages) {
            if (page.style.display !== 'none') {
                visibleContainer = page;
                console.log('âœ“ Found visible page, searching only there');
                break;
            }
        }
    }

    const rangeInfo = findTextRangeAcrossNodes(visibleContainer, text);  // Changed from 'container' to 'visibleContainer'

    // âœ… NEW: If text not found, insert at END as "unlocated"
    if (!rangeInfo) {
        console.warn('âš ï¸ Could not locate text, inserting at end:', annotation.id);
        insertUnlocatedAnnotation(annotation, container, text, type, color, annotationId);
        return;
    }

    const { textNodes } = collectVisibleTextNodes(container);
    const startIndex = textNodes.findIndex(info => info.node === rangeInfo.startNode);
    const endIndex = textNodes.findIndex(info => info.node === rangeInfo.endNode);

    if (startIndex === -1 || endIndex === -1) {
        console.warn('âš ï¸ Could not map text nodes, inserting at end:', annotation.id);
        insertUnlocatedAnnotation(annotation, container, text, type, color, annotationId);
        return;
    }

    const segments = [];

    for (let i = startIndex; i <= endIndex; i++) {
        const info = textNodes[i];
        if (!info || !info.node || info.node.nodeType !== Node.TEXT_NODE) {
            continue;
        }

        const startOffset = (i === startIndex) ? rangeInfo.startOffset : 0;
        const endOffset = (i === endIndex) ? rangeInfo.endOffset : info.node.textContent.length;

        if (startOffset < endOffset) {
            segments.push({
                node: info.node,
                startOffset,
                endOffset
            });
        }
    }

    if (!segments.length) {
        console.warn('âš ï¸ No text segments identified, inserting at end:', annotation.id);
        insertUnlocatedAnnotation(annotation, container, text, type, color, annotationId);
        return;
    }

    const typeIdValue = annotation.annotation_type?.id ?? annotation.annotation_type_id ?? annotation.type_id ?? null;
    const segmentSpans = new Array(segments.length);
    const rgb = hexToRgb(color);
    const bgColor = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `${color}33`;

    for (let i = segments.length - 1; i >= 0; i--) {
        const segment = segments[i];
        const baseNode = segment.node;
        const startOffset = segment.startOffset;
        const segmentLength = segment.endOffset - segment.startOffset;

        if (!baseNode || baseNode.nodeType !== Node.TEXT_NODE || segmentLength <= 0) {
            continue;
        }

        const selectionStartNode = baseNode.splitText(startOffset);
        const afterSelectionNode = selectionStartNode.splitText(segmentLength);

        const span = document.createElement('span');
        span.className = 'inline-annotation structured-inline-annotation';
        span.dataset.annotationId = annotation.id;
        span.dataset.annotationArea = 'structured';
        span.dataset.segmentIndex = String(i);
        if (typeIdValue) {
            span.dataset.annotationTypeId = String(typeIdValue);
        }

        span.style.cssText = `
            background-color: ${bgColor};
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            padding: 2px 4px;
            margin: 0 1px;
            border-radius: 3px;
            cursor: pointer;
        `;

        span.textContent = selectionStartNode.textContent;
        span.setAttribute('data-original-text', selectionStartNode.textContent);

        selectionStartNode.parentNode.replaceChild(span, selectionStartNode);
        segmentSpans[i] = span;
    }

    const firstSpan = segmentSpans[0];

    if (firstSpan) {
        firstSpan.dataset.annotationRoot = 'true';
        attachStructuredAnnotationLabel(firstSpan, type);

        // DEBUG: Check visibility
        setTimeout(() => {
            const rect = firstSpan.getBoundingClientRect();
            const isVisible = rect.width > 0 && rect.height > 0;

            if (!isVisible) {
                console.warn('âš ï¸ Annotation NOT visible:', annotation.id);
                firstSpan.remove();
            } else {
                console.log('âœ… Annotation visible:', annotation.id);
            }
        }, 100);
    }

    addAnnotationEventListeners();

    console.log('âœ… Restored by text with multi-node highlight:', annotation.id);
    return true;
}


function attachStructuredAnnotationLabel(span, labelText) {
    if (!span) {
        return;
    }

    const label = document.createElement('span');
    label.className = 'ann-label';
    label.style.cssText = `
        font-size: 0.7rem;
        font-weight: bold;
        margin-left: 4px;
        padding: 2px 6px;
        border-radius: 4px;
        background: rgba(0,0,0,0.6);
        color: #fff;
        white-space: nowrap;
        display: none;
        opacity: 0;
    `;
    label.textContent = labelText;
    span.appendChild(label);
}

function removeStructuredAnnotationFromDom(annotationId) {
    const spans = Array.from(document.querySelectorAll(`.inline-annotation[data-annotation-id="${annotationId}"][data-annotation-area="structured"]`));

    spans.forEach(span => {
        const label = span.querySelector('.ann-label');
        if (label) {
            label.remove();
        }

        const originalText = span.getAttribute('data-original-text') || span.textContent || '';
        const textNode = document.createTextNode(originalText);

        if (span.parentNode) {
            span.parentNode.replaceChild(textNode, span);
        }
    });
}


// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Build type mapping - seulement si Mistral n'a pas encore analys&eacute; ce document
    {% if not document.mistral_analyzed %}
    {% for ann_type in annotation_types %}
    annotationTypeMap['{{ ann_type.name|escapejs }}'] = {{ ann_type.id }};
    {% endfor %}
    {% endif %}

    console.log(' Annotation type mapping loaded:', annotationTypeMap);

    // Initialize Prodigy-like toolbar
    initializeProdigyToolbar();

    // Load and render existing annotations in both areas
    loadAndRenderAnnotations();
    loadAnnotationsInStructuredContent(); // Ajout de cette ligne

    // Initialize modals and existing functionality
    initializeModals();
    initializeExistingFunctionality();

    // Charger automatiquement les types d'annotation sugg&eacute;r&eacute;s par Mistral
    // V&eacute;rifier d'abord le cache pour &eacute;viter les appels multiples
    checkMistralCacheAndLoad();

    // Charger automatiquement les types Llama en cache si disponibles
    loadLlamaCachedTypes();
});

function showTab(tabName) {
    // Hide all tab contents
    const contents = document.getElementsByClassName('content-panel');
    for (let content of contents) {
        content.style.display = 'none';
    }

    // Show the selected tab content
    document.getElementById(tabName + '-content').style.display = 'block';

    // Update active tab button
    const tabs = document.getElementsByClassName('tab-btn');
    for (let tab of tabs) {
        tab.classList.remove('active');
    }
    document.getElementById(tabName + '-tab').classList.add('active');
}

function initializeProdigyToolbar() {
    const pageEl = document.getElementById("page-text");
    const structuredArea = document.getElementById("structured-annotation-area");

    // G&eacute;rer les boutons de type d'annotation (code existant)
    document.querySelectorAll(".label-btn").forEach(btn => {
        btn.addEventListener("click", () => {
            // Remove active from all
            document.querySelectorAll(".label-btn").forEach(b => b.classList.remove("active"));

            // Skip if it's a special button
            if (btn.id === 'clear-annotations-btn' || btn.classList.contains('annotation-type-btn-add')) {
                return;
            }

            // Activate selected
            btn.classList.add("active");
            currentLabel = {
                id: btn.dataset.id,
                name: btn.dataset.name,
                color: btn.dataset.color
            };

            // Update for compatibility with existing code
            selectedAnnotationType = btn.dataset.name;
            selectedColor = btn.dataset.color;
        });

        // Add right-click context menu (keep existing functionality)
        if (!btn.classList.contains('annotation-type-btn-add') && btn.id !== 'clear-annotations-btn') {
            btn.addEventListener('contextmenu', handleRightClick);
        }
    });

    // Ajouter les &eacute;v&eacute;nements de s&eacute;lection pour les deux zones
    if (pageEl) {
        pageEl.addEventListener("mouseup", handleTextSelection);
    }

    if (structuredArea) {
        structuredArea.addEventListener("mouseup", handleTextSelection);

        // Prevent editing while allowing selection
        structuredArea.addEventListener("keydown", function(e) {
            // Allow navigation keys only
            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) &&
                !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
            }
        });

        structuredArea.addEventListener("paste", function(e) {
            e.preventDefault();
        });

        // Important: prevent contenteditable behavior
        structuredArea.contentEditable = "false";
        structuredArea.style.userSelect = "text";
        structuredArea.style.webkitUserSelect = "text";
    }

    // Clear button (code existant)
    document.getElementById("clear-annotations-btn").addEventListener("click", () => {
        if (confirm('Effacer toutes les annotations de cette page ?')) {
            clearPageAnnotations();
        }
    });
}

function loadAndRenderAnnotations() {
    const pageEl = document.getElementById("page-text");
    const pageId = pageEl.dataset.pageId;

    const originalText = `{{ page_text|escapejs }}`;
    const displayOriginalText = (originalText || '').trimStart();
    const previousScrollTop = pageEl.scrollTop;
    const previousScrollLeft = pageEl.scrollLeft;

    console.log(' Loading RAW text annotations for page:', pageId);
    console.log(' Timestamp:', new Date().toISOString());

    fetch(`/annotation/page/${pageId}/`)
        .then(response => response.json())
        .then(data => {
            console.log(' Received annotation data:', data);
            console.log(' Total annotations in response:', data.annotations ? data.annotations.length : 0);

            if (data.annotations && data.annotations.length > 0) {
                // Log all annotation IDs for debugging
                const annotationIds = data.annotations.map(ann => ann.id);
                console.log(' Annotation IDs found:', annotationIds);
            }

            if (data.success && data.annotations && data.annotations.length > 0) {
                // FILTER: Only process raw text annotations
                const rawAnnotations = data.annotations.filter(ann =>['raw', 'structured', null, undefined].includes(ann.mode));

                console.log(` Found ${rawAnnotations.length} RAW annotations (${data.annotations.length} total)`);

                if (rawAnnotations.length > 0) {
                    renderInlineAnnotations(displayOriginalText, rawAnnotations);
                } else {
                    console.log('? No RAW annotations, showing clean text');
                    pageEl.textContent = displayOriginalText;
                }
            } else {
                console.log('? No annotations found, showing clean text');
                pageEl.textContent = displayOriginalText;
            }
        })
        .catch(error => {
            console.error(' Error loading annotations:', error);
            pageEl.textContent = displayOriginalText;
        })
        .finally(() => {
            trimLeadingWhitespace(pageEl);
            pageEl.scrollTop = previousScrollTop;
            pageEl.scrollLeft = previousScrollLeft;
        });
}


function renderInlineAnnotations(originalText, annotations) {
    const pageEl = document.getElementById("page-text");

    if (!annotations || annotations.length === 0) {
        pageEl.textContent = originalText;
        trimLeadingWhitespace(pageEl);
        return;
    }

    console.log(' Rendering', annotations.length, 'annotations');

    let workingText = originalText;
    const sortedAnnotations = [...annotations].sort((a, b) => b.selected_text.length - a.selected_text.length);

    let processedAnnotations = 0;

    for (let ann of sortedAnnotations) {
        const searchText = ann.selected_text.trim();

        // CRITICAL FIX: Normalize whitespace for matching
        const normalizedSearchText = searchText.replace(/\s+/g, ' ');
        const normalizedWorkingText = workingText.replace(/\s+/g, ' ');

        // Try exact match first
        let startIndex = workingText.indexOf(searchText);

        // If exact match fails, try normalized match
        if (startIndex === -1) {
            const normalizedIndex = normalizedWorkingText.indexOf(normalizedSearchText);
            if (normalizedIndex !== -1) {
                // Find the original position by counting characters
                let charCount = 0;
                for (let i = 0; i < workingText.length; i++) {
                    if (!/\s/.test(workingText[i])) charCount++;
                    if (charCount === normalizedIndex) {
                        startIndex = i;
                        break;
                    }
                }
            }
        }

        if (startIndex !== -1) {
            const actualText = workingText.slice(startIndex, startIndex + searchText.length);

            const annotationHtml = `<span class="inline-annotation" data-annotation-id="${ann.id}" data-original-text="${actualText.replace(/"/g, '&quot;')}" style="background-color: ${ann.color}20; color: inherit; padding: 1px 3px; margin: 0 1px; border-radius: 3px; cursor: pointer;">${actualText}<span class="ann-label" style="display: none;">${ann.type_display}</span></span>`;

            workingText = workingText.slice(0, startIndex) + annotationHtml + workingText.slice(startIndex + searchText.length);

            processedAnnotations++;
            console.log(' Processed annotation:', searchText.substring(0, 50));
        } else {
            console.log(' Could not find text:', searchText.substring(0, 80));
        }
    }

    console.log(` Successfully processed ${processedAnnotations}/${annotations.length} annotations`);

    pageEl.innerHTML = workingText;
    addAnnotationEventListeners();
    trimLeadingWhitespace(pageEl);

    // Add deletion handlers
    pageEl.querySelectorAll('.inline-annotation').forEach(annotation => {
        annotation.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            window.getSelection().removeAllRanges();

            const annotationId = this.dataset.annotationId;
            const originalText = this.getAttribute('data-original-text');

            if (originalText) {
                const textNode = document.createTextNode(originalText);
                this.parentNode.replaceChild(textNode, this);
            } else {
                const label = this.querySelector('.ann-label');
                let textContent = '';
                for (let node of this.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    } else if (node !== label && node.nodeType === Node.ELEMENT_NODE) {
                        textContent += node.textContent;
                    }
                }
                const textNode = document.createTextNode(textContent);
                this.parentNode.replaceChild(textNode, this);
            }

            deleteAnnotationFromDB(annotationId);
        });
    });
}





function handleTextSelection() {
    const selection = window.getSelection();

    if (!selection.rangeCount || !selection.toString().trim()) {
        return;
    }

    const range = selection.getRangeAt(0);
    if (isWithinAnnotation(range)) {
        selection.removeAllRanges();
        return;
    }

    if (!currentLabel) {
        showSelectionAlert('Veuillez d\'abord sÃ©lectionner un type d\'annotation');
        return;
    }

    // CRITICAL FIX: Get the selected text and trim it immediately
    const rawSelectedText = selection.toString();
    const selectedText = rawSelectedText.trim();

    // CRITICAL FIX: Check if selection is only whitespace BEFORE doing anything
    if (isWhitespaceOnly(selectedText)) {
        console.warn('âš ï¸ Skipping whitespace-only selection');
        selection.removeAllRanges();
        return;
    }

    console.log('ðŸ“ Texte sÃ©lectionnÃ©:', {
        'original length': rawSelectedText.length,
        'trimmed length': selectedText.length,
        'trimmed text': JSON.stringify(selectedText)
    });

    // Determine which area (page-text or structured-annotation-area)
    let targetArea = null;
    let pageId = null;

    const pageTextElement = document.getElementById("page-text");
    if (pageTextElement && pageTextElement.contains(range.commonAncestorContainer)) {
        targetArea = pageTextElement;
        pageId = targetArea.dataset.pageId;
    }
    else if (document.getElementById("structured-annotation-area") &&
             document.getElementById("structured-annotation-area").contains(range.commonAncestorContainer)) {
        targetArea = document.getElementById("structured-annotation-area");
        pageId = targetArea.dataset.pageId;

        // STRUCTURED CONTENT HANDLING - TRIMMED VERSION
        console.log('ðŸ“ Structured area - wrapping:', selectedText.substring(0, 50));

        try {
            // Single node selection
            if (range.startContainer === range.endContainer && range.startContainer.nodeType === 3) {
                console.log('âœ“ Single node selection detected');

                const tempAnnotationId = 'temp-' + Date.now();
                const textNode = range.startContainer;
                const span = document.createElement('span');
                span.className = 'inline-annotation';
                span.dataset.annotationId = tempAnnotationId;
                span.dataset.annotationArea = 'structured';
                span.dataset.annotationRoot = 'true';
                span.dataset.tempGroup = tempAnnotationId;
                span.dataset.segmentIndex = '0';
                span.style.background = currentLabel.color;
                span.style.padding = '2px 4px';
                span.style.margin = '0';
                span.style.borderRadius = '3px';
                span.style.cursor = 'pointer';

                const before = textNode.textContent.substring(0, range.startOffset);
                const originalSelection = textNode.textContent.substring(range.startOffset, range.endOffset);
                const after = textNode.textContent.substring(range.endOffset);

                // CRITICAL FIX: Trim the selected portion to remove leading/trailing whitespace
                const trimmedSelection = originalSelection.trim();

                // Calculate the offset adjustment for trimming
                const leadingSpaces = originalSelection.length - originalSelection.trimStart().length;
                const trailingSpaces = originalSelection.length - originalSelection.trimEnd().length;

                // Adjust the before and after text to include trimmed spaces
                const adjustedBefore = before + originalSelection.substring(0, leadingSpaces);
                const adjustedAfter = originalSelection.substring(originalSelection.length - trailingSpaces) + after;

                console.log('âœ‚ï¸ Trimming whitespace:', {
                    original: JSON.stringify(originalSelection),
                    trimmed: JSON.stringify(trimmedSelection),
                    leadingSpaces,
                    trailingSpaces
                });

                // Use trimmed text for the span
                span.textContent = trimmedSelection;
                span.setAttribute('data-original-text', trimmedSelection);
                span.setAttribute('data-before-text', adjustedBefore);
                span.setAttribute('data-after-text', adjustedAfter);

                // Add label
                const label = document.createElement('span');
                label.className = 'ann-label';
                label.style.cssText = 'font-size:0.7rem;font-weight:bold;margin-left:4px;padding:2px 6px;border-radius:4px;background:rgba(0,0,0,0.6);color:#fff;';
                label.textContent = currentLabel.name;
                span.appendChild(label);

                // Insert nodes
                textNode.parentNode.insertBefore(document.createTextNode(adjustedBefore), textNode);
                textNode.parentNode.insertBefore(span, textNode);
                textNode.parentNode.insertBefore(document.createTextNode(adjustedAfter), textNode);
                textNode.remove();

                // Click handler
                span.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const originalText = this.getAttribute('data-original-text');
                    const beforeText = this.getAttribute('data-before-text');
                    const afterText = this.getAttribute('data-after-text');

                    if (originalText && beforeText !== null && afterText !== null) {
                        const fullText = beforeText + originalText + afterText;
                        const textNode = document.createTextNode(fullText);
                        const parentNode = this.parentNode;
                        const prevSibling = this.previousSibling;
                        const nextSibling = this.nextSibling;

                        if (prevSibling && prevSibling.nodeType === Node.TEXT_NODE) {
                            prevSibling.remove();
                        }
                        if (nextSibling && nextSibling.nodeType === Node.TEXT_NODE) {
                            nextSibling.remove();
                        }

                        this.replaceWith(textNode);
                    }
                });

                console.log('âœ… Single word annotated (trimmed)');

                // Save with TRIMMED text
                saveManualAnnotation({
                    page_id: pageId,
                    type_id: currentLabel.id,
                    selected_text: trimmedSelection,  // Use trimmed!
                    start_pos: 0,
                    end_pos: trimmedSelection.length,
                    mode: 'structured',
                    temp_id: tempAnnotationId
                });

                selection.removeAllRanges();
                return;
            }

            // Multi-node handling
            const textNodes = [];
            const walker = document.createTreeWalker(
                range.commonAncestorContainer,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        const nodeRange = document.createRange();
                        nodeRange.selectNodeContents(node);
                        if (range.compareBoundaryPoints(Range.START_TO_END, nodeRange) > 0 &&
                            range.compareBoundaryPoints(Range.END_TO_START, nodeRange) < 0) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        return NodeFilter.FILTER_REJECT;
                    }
                }
            );

            let node;
            while (node = walker.nextNode()) {
                // âœ… Skip text nodes that are ONLY whitespace/newlines
                const nodeText = node.textContent || '';
                if (!isWhitespaceOnly(nodeText)) {
                    textNodes.push(node);
                } else {
                    console.log('â­ï¸ Skipping whitespace-only node:', JSON.stringify(nodeText));
                }
            }

            console.log('Found', textNodes.length, 'text nodes');

            const tempAnnotationId = 'temp-' + Date.now();

            textNodes.forEach((textNode, idx) => {
                const span = document.createElement('span');
                span.className = 'inline-annotation';
                span.dataset.annotationId = tempAnnotationId;
                span.dataset.annotationArea = 'structured';
                span.dataset.tempGroup = tempAnnotationId;
                span.dataset.segmentIndex = String(idx);
                if (idx === 0) {
                    span.dataset.annotationRoot = 'true';
                }
                span.style.background = currentLabel.color;
                span.style.padding = '2px 4px';
                span.style.margin = '0';
                span.style.borderRadius = '3px';
                span.style.cursor = 'pointer';

                const isStart = textNode === range.startContainer;
                const isEnd = textNode === range.endContainer;

                let text;
                if (isStart && isEnd) {
                    text = textNode.textContent.substring(range.startOffset, range.endOffset);

                    // âœ… TRIM the extracted text
                    const trimmedText = text.trim();

                    // âœ… Skip if only whitespace after trimming
                    if (isWhitespaceOnly(trimmedText)) {
                        console.log('â­ï¸ Skipping whitespace in start-end node');
                        return;
                    }

                    const before = textNode.textContent.substring(0, range.startOffset);
                    const after = textNode.textContent.substring(range.endOffset);

                    span.textContent = trimmedText;
                    span.setAttribute('data-original-text', trimmedText);
                    if (idx === 0) {
                        const label = document.createElement('span');
                        label.className = 'ann-label';
                        label.style.cssText = 'font-size:0.7rem;font-weight:bold;margin-left:4px;padding:2px 6px;border-radius:4px;background:rgba(0,0,0,0.6);color:#fff;';
                        label.textContent = currentLabel.name;
                        span.appendChild(label);
                    }

                    textNode.parentNode.insertBefore(document.createTextNode(before), textNode);
                    textNode.parentNode.insertBefore(span, textNode);
                    textNode.parentNode.insertBefore(document.createTextNode(after), textNode);
                    textNode.remove();
                } else if (isStart) {
                    text = textNode.textContent.substring(range.startOffset);

                    // âœ… TRIM the extracted text
                    const trimmedText = text.trim();

                    // âœ… Skip if only whitespace after trimming
                    if (isWhitespaceOnly(trimmedText)) {
                        console.log('â­ï¸ Skipping whitespace in start node');
                        return;
                    }

                    const before = textNode.textContent.substring(0, range.startOffset);

                    span.textContent = trimmedText;
                    span.setAttribute('data-original-text', trimmedText);
                    const label = document.createElement('span');
                    label.className = 'ann-label';
                    label.style.cssText = 'font-size:0.7rem;font-weight:bold;margin-left:4px;padding:2px 6px;border-radius:4px;background:rgba(0,0,0,0.6);color:#fff;';
                    label.textContent = currentLabel.name;
                    span.appendChild(label);

                    textNode.parentNode.insertBefore(document.createTextNode(before), textNode);
                    textNode.parentNode.insertBefore(span, textNode);
                    textNode.remove();
                } else if (isEnd) {
                    text = textNode.textContent.substring(0, range.endOffset);

                    // âœ… TRIM the extracted text
                    const trimmedText = text.trim();

                    // âœ… Skip if only whitespace after trimming
                    if (isWhitespaceOnly(trimmedText)) {
                        console.log('â­ï¸ Skipping whitespace in end node');
                        return;
                    }

                    const after = textNode.textContent.substring(range.endOffset);

                    span.textContent = trimmedText;
                    span.setAttribute('data-original-text', trimmedText);
                    textNode.parentNode.insertBefore(span, textNode);
                    textNode.parentNode.insertBefore(document.createTextNode(after), textNode);
                    textNode.remove();
                } else {
                    text = textNode.textContent;

                    // âœ… TRIM the extracted text
                    const trimmedText = text.trim();

                    // âœ… Skip if only whitespace after trimming
                    if (isWhitespaceOnly(trimmedText)) {
                        console.log('â­ï¸ Skipping whitespace in middle node');
                        return;
                    }

                    span.textContent = trimmedText;
                    span.setAttribute('data-original-text', trimmedText);
                    textNode.parentNode.replaceChild(span, textNode);
                }

                span.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const stored = this.getAttribute('data-original-text');
                    if (stored !== null) {
                        this.replaceWith(document.createTextNode(stored));
                    }
                });
            });

            console.log('âœ… Wrapped', textNodes.length, 'nodes (trimmed)');

            // Save with TRIMMED text
            saveManualAnnotation({
                page_id: pageId,
                type_id: currentLabel.id,
                selected_text: selectedText,  // Already trimmed!
                start_pos: 0,
                end_pos: selectedText.length,
                mode: 'structured',
                temp_id: tempAnnotationId
            });

        } catch (error) {
            console.error('Error:', error);
            alert('Error: ' + error.message);
        }

        selection.removeAllRanges();
        return;
    }

    if (!targetArea || !pageId) {
        showSelectionAlert('Veuillez sÃ©lectionner du texte dans une zone d\'annotation valide');
        return;
    }

    // RAW TEXT AREA HANDLING (existing code)
    const cleanText = targetArea.textContent || targetArea.innerText;
    let startPos = cleanText.toLowerCase().indexOf(selectedText.toLowerCase());

    if (startPos === -1) {
        showSelectionAlert('Impossible de localiser le texte sÃ©lectionnÃ©.');
        return;
    }

    const endPos = startPos + selectedText.length;
    const tempAnnotationId = 'temp-' + Date.now();

    const span = document.createElement("span");
    span.classList.add("inline-annotation");
    span.dataset.annotationId = tempAnnotationId;
    span.dataset.tempGroup = tempAnnotationId;
    span.dataset.annotationArea = 'raw';
    span.dataset.annotationRoot = 'true';
    span.style.background = currentLabel.color;
    span.style.padding = "2px 4px";
    span.style.margin = "0 1px";
    span.style.borderRadius = "3px";
    span.style.cursor = "pointer";
    span.setAttribute('data-original-text', selectedText);  // Use trimmed!
    span.innerHTML = selectedText + `<span class="ann-label" style="font-size: 0.7rem; font-weight: bold; margin-left: 4px; padding: 2px 6px; border-radius: 4px; background: rgba(0,0,0,0.6); color: #fff; white-space: nowrap;">${currentLabel.name}</span>`;

    addClickHandlerToTempAnnotation(span);

    try {
        range.deleteContents();
        range.insertNode(span);
    } catch (e) {
        console.error('Error inserting annotation:', e);
    }

    // Save with TRIMMED text
    saveManualAnnotation({
        page_id: pageId,
        type_id: currentLabel.id,
        selected_text: selectedText,  // Use trimmed!
        start_pos: startPos,
        end_pos: endPos,
        temp_id: tempAnnotationId,
        mode: 'raw'
    });

    selection.removeAllRanges();
}

function isWithinAnnotation(range) {
    const startContainer = range.startContainer;
    const endContainer = range.endContainer;

    // V&eacute;rifier si la s&eacute;lection est dans une annotation existante
    let withinAnnotation = false;

    [startContainer, endContainer].forEach(container => {
        let node = container;
        while (node && node !== document.body) {
            if (node.nodeType === Node.ELEMENT_NODE &&
                node.classList && node.classList.contains('inline-annotation')) {
                withinAnnotation = true;
                break;
            }
            node = node.parentNode;
        }
    });

    return withinAnnotation;
}

function showSelectionAlert(message) {
    const alert = document.createElement('div');
    alert.className = 'validation-success';
    alert.style.background = 'linear-gradient(90deg, #f59e0b, #d97706)';
    alert.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message}`;
    document.body.appendChild(alert);

    setTimeout(() => alert.remove(), 3000);
}

// Fonction pour g&eacute;rer le zoom du contenu structur&eacute;
function toggleZoom() {
    const container = document.getElementById('structured-content-container');
    const btn = document.querySelector('.zoom-content-btn');
    const btnIcon = btn.querySelector('i');
    const btnText = btn.querySelector('span');

    if (container.classList.contains('zoomed')) {
        // D&eacute;zoomer
        container.classList.remove('zoomed');
        container.style.transform = 'scale(1)';
        container.style.maxHeight = '';
        container.style.overflowY = '';
        btnIcon.className = 'fas fa-search-plus';
        btnText.textContent = 'Zoom';
        btn.classList.remove('zoomed');
    } else {
        // Zoomer
        container.classList.add('zoomed');
        container.style.transform = 'scale(1.1)';
        container.style.maxHeight = '80vh';
        container.style.overflowY = 'auto';
        btnIcon.className = 'fas fa-search-minus';
        btnText.textContent = 'D&eacute;zoom';
        btn.classList.add('zoomed');
    }
}

function toggleStructuredContent() {
    const section = document.querySelector('.structured-content-section');
    const container = document.getElementById('structured-content-container');
    const btn = document.querySelector('.toggle-content-btn');
    const btnIcon = btn.querySelector('i');
    const btnText = btn.querySelector('span');

    if (container.style.display === 'none') {
        // Afficher le contenu
        container.style.display = 'block';
        container.style.animation = 'fadeInDown 0.3s ease-out';
        btnIcon.className = 'fas fa-eye-slash';
        btnText.textContent = 'Masquer';
        btn.classList.remove('btn-show');
        section.classList.remove('content-hidden');
    } else {
        // Masquer le contenu
        container.style.animation = 'fadeOutUp 0.3s ease-out';
        setTimeout(() => {
            container.style.display = 'none';
            section.classList.add('content-hidden');
        }, 280);
        btnIcon.className = 'fas fa-eye';
        btnText.textContent = 'Afficher';
        btn.classList.add('btn-show');
    }
}

function makeContentNonEditable() {
    const structuredArea = document.getElementById("structured-annotation-area");
    if (!structuredArea) return;

    // D&eacute;sactiver tous les &eacute;l&eacute;ments &eacute;ditables
    const editableElements = structuredArea.querySelectorAll('input, textarea, select, button, [contenteditable]');
    editableElements.forEach(element => {
        element.disabled = true;
        element.style.pointerEvents = 'none';
        element.style.background = '#e9ecef';
        element.style.cursor = 'not-allowed';
        if (element.hasAttribute('contenteditable')) {
            element.removeAttribute('contenteditable');
        }
    });

    // Emp&ecirc;cher la modification directe du texte
    structuredArea.addEventListener('input', function(e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    });

    structuredArea.addEventListener('beforeinput', function(e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    });
}

// Appeler cette fonction apr&egrave;s le chargement
document.addEventListener('DOMContentLoaded', function() {
    // Votre code existant...

    // Rendre le contenu non-&eacute;ditable
    setTimeout(makeContentNonEditable, 100);
});

function deleteAnnotationFromDB(annotationId, csrfToken) {
    const token = csrfToken || getCookie('csrftoken');
    console.log('ðŸ”‘ Deleting with CSRF token:', token ? token.substring(0, 10) + '...' : 'MISSING');
    console.log('ðŸ”‘ Token from hidden input:', document.querySelector('[name=csrfmiddlewaretoken]')?.value?.substring(0, 10));
    console.log('ðŸ”‘ Token from cookie:', getCookie('csrftoken')?.substring(0, 10));

    fetch(`/annotation/${annotationId}/delete/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken || getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })

    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log(' Annotation supprim&eacute;e avec succ&egrave;s:', annotationId);

            // CRITICAL: Force JSON refresh after successful deletion
            setTimeout(() => {
                updateExpertJSON();
            }, 300);
        } else {
            console.error('Delete failed:', data.error);
        }
    })
    .catch(error => {
        console.error('Error deleting annotation:', error);
    });
}


function deleteAnnotationSimple(annotationId) {
    // No confirmation, immediate delete like Prodigy
    fetch(`/annotation/${annotationId}/delete/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken')
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Immediately reload annotations to show updated state
            loadAndRenderAnnotations();
        } else {
            console.error('Delete failed:', data.error);
        }
    })
    .catch(error => {
        console.error('Error deleting annotation:', error);
    });
}

function clearPageAnnotations() {
    const pageId = document.getElementById("page-text").dataset.pageId;

    // Clear all annotations for this page
    fetch(`/clear_page_annotations/${pageId}/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Nettoyer la zone principale
            loadAndRenderAnnotations();

            // Nettoyer le contenu structur&eacute;
            const structuredContent = document.querySelector('.structured-content-body');
            if (structuredContent) {
                // Sauvegarder le contenu texte original sans annotations
                const originalText = structuredContent.innerText;

                // Supprimer toutes les annotations en pr&eacute;servant l'espacement
                const annotations = structuredContent.querySelectorAll('.inline-annotation');
                annotations.forEach(annotation => {
                    // Extraire le texte en pr&eacute;servant les espaces
                    const labelElement = annotation.querySelector('.ann-label');
                    let annotationText = annotation.textContent;
                    if (labelElement) {
                        annotationText = annotationText.replace(labelElement.textContent, '');
                    }

                    // NE PAS utiliser trim() - pr&eacute;server l'espacement original
                    const textNode = document.createTextNode(annotationText);
                    annotation.parentNode.insertBefore(textNode, annotation);
                    annotation.parentNode.removeChild(annotation);
                });

                // Normaliser les nuds de texte adjacents
                structuredContent.normalize();
            }

            showSuccessMessage('Toutes les annotations ont &eacute;t&eacute; supprim&eacute;es');
        }
    })
    .catch(error => {
        console.error('Error clearing annotations:', error);
        showErrorMessage('Erreur lors de la suppression des annotations');
    });
}
function saveManualAnnotation(data) {
    // CRITICAL: Determine which area was annotated
    const structuredArea = document.getElementById('structured-annotation-area');
    const pageTextArea = document.getElementById('page-text');

    const structuredScrollTopBefore = structuredArea ? structuredArea.scrollTop : null;
    const structuredScrollLeftBefore = structuredArea ? structuredArea.scrollLeft : null;
    const rawScrollTopBefore = pageTextArea ? pageTextArea.scrollTop : null;

    const rawSelectedText = data.selected_text || '';
    if (isWhitespaceOnly(rawSelectedText)) {
        console.warn('?? Ignoring manual annotation with empty or whitespace-only selection');
        return;
    }
    const selectedText = rawSelectedText;


    // Check if the annotation was made in structured content
    const selection = window.getSelection();
    const wasInStructured = structuredArea && structuredArea.contains(selection.anchorNode);

    // FORCE the correct mode based on where annotation was created
    const payload = {
        page_id: data.page_id,
        type_id: data.type_id || data.annotation_type_id || data.type || data.entity_type_id,
        selected_text: selectedText,
        start_pos: typeof data.start_pos === 'number' ? data.start_pos : parseInt(data.start_pos || 0, 10),
        end_pos: typeof data.end_pos === 'number' ? data.end_pos : parseInt(data.end_pos || 0, 10),
        mode: wasInStructured ? 'structured' : 'raw',
        temp_id: data.temp_id || null
    };

    console.log(` Saving annotation with mode: ${payload.mode} (wasInStructured: ${wasInStructured})`);

    fetch("{% url 'rawdocs:save_manual_annotation' %}", {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(result => {
        if (result.success) {
            const realId = result.annotation_id;
            const tempGroupId = data.temp_id || payload.temp_id || null;
            console.log(` Annotation saved with ID ${realId}, mode: ${result.mode}`);

            const finalizeTempAnnotations = (groupId) => {
                const tempElements = document.querySelectorAll(`[data-temp-group="${groupId}"]`);
                tempElements.forEach((element, idx) => {
                    element.dataset.annotationId = realId;
                    element.dataset.annotationArea = wasInStructured ? 'structured' : 'raw';
                    if (wasInStructured && idx === 0) {
                        element.dataset.annotationRoot = 'true';
                    } else {
                        element.removeAttribute('data-annotation-root');
                    }
                    element.removeAttribute('data-temp-group');
                    if (!element.getAttribute('data-original-text')) {
                        element.setAttribute('data-original-text', element.textContent);
                    }
                    const clone = element.cloneNode(true);
                    element.parentNode.replaceChild(clone, element);
                });
                trimLeadingWhitespace(structuredArea);
            };

            if (tempGroupId) {
                finalizeTempAnnotations(tempGroupId);
            }

            addAnnotationEventListeners();

            if (structuredArea && structuredScrollTopBefore !== null) {
                structuredArea.scrollTop = structuredScrollTopBefore;
                if (structuredScrollLeftBefore !== null) {
                    structuredArea.scrollLeft = structuredScrollLeftBefore;
                }
                trimLeadingWhitespace(structuredArea);
            }
            if (pageTextArea) {
                if (pageTextArea && rawScrollTopBefore !== null) {
                    pageTextArea.scrollTop = rawScrollTopBefore;
                }
                trimLeadingWhitespace(pageTextArea);
            }

            const visualList = document.getElementById('visual-annotations-list');
            const visualScrollTop = visualList ? visualList.scrollTop : null;
            loadVisualAnnotations();
            if (visualScrollTop !== null) {
                setTimeout(() => {
                    const refreshedList = document.getElementById('visual-annotations-list');
                    if (refreshedList) {
                        refreshedList.scrollTop = visualScrollTop;
                    }
                }, 150);
            }

        } else {
            console.error(' Save failed:', result.error);
            alert('Error: ' + result.error);
        }
    })
    .catch(error => {
        console.error(' Network error:', error);
        alert('Error saving annotation');
    });
}

function addClickHandlerToTempAnnotation(span) {
    span.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        window.getSelection().removeAllRanges();

        // Pour les annotations temporaires, supprimer simplement visuellement
        if (this.dataset.annotationId.startsWith('temp-')) {
            this.remove();
        } else {
            // Utiliser le texte original stock&eacute; pour une restauration exacte
            const originalText = this.getAttribute('data-original-text');

            if (originalText) {
                // Restauration exacte du texte original
                const textNode = document.createTextNode(originalText);
                this.parentNode.insertBefore(textNode, this);
                this.parentNode.removeChild(this);
            } else {
                // M&eacute;thode de fallback si pas de texte stock&eacute;
                const labelElement = this.querySelector('.ann-label');
                let textContent = '';

                // Parcourir les nuds enfants pour extraire seulement le texte (pas le label)
                for (let node of this.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    } else if (node !== labelElement && node.nodeType === Node.ELEMENT_NODE) {
                        textContent += node.textContent;
                    }
                }

                const textNode = document.createTextNode(textContent);
                this.parentNode.insertBefore(textNode, this);
                this.parentNode.removeChild(this);
            }

            // Supprimer l'annotation de la base de donn&eacute;es
            deleteAnnotationFromDB(this.dataset.annotationId);
        }
    });
}

// Position calculation function for annotated text
function getTextPosition(container, node, offset) {
    let position = 0;
    const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );

    let currentNode;
    while (currentNode = walker.nextNode()) {
        if (currentNode === node) {
            return position + offset;
        }
        position += currentNode.textContent.length;
    }
    return position;
}

function getAnnotationTypeId(typeName) {
    console.log(' Looking for type:', typeName);
    console.log(' Available types:', annotationTypeMap);

    const typeId = annotationTypeMap[typeName];
    if (!typeId) {
        console.error(' Type ID not found for:', typeName);
        console.error('Available types:', Object.keys(annotationTypeMap));
        return null;
    }

    console.log(' Found type ID:', typeId, 'for type:', typeName);
    return typeId;
}

// Initialize existing functionality
function initializeModals() {
    const editModalElement = document.getElementById('editAnnotationModal');
    if (editModalElement) {
        editModal = new bootstrap.Modal(editModalElement, {
            backdrop: true,
            keyboard: true,
            focus: true
        });
    }
}

function initializeExistingFunctionality() {
    // Auto-generate technical name from display name
    const displayNameInput = document.getElementById('new-annotation-display-name');
    if (displayNameInput) {
        displayNameInput.addEventListener('input', function() {
            const displayName = this.value;
            const technicalName = displayName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
            document.getElementById('new-annotation-name').value = technicalName;
        });
    }

    // Mark validated pages
    const validateBtn = document.getElementById('validate-page-btn');
    if (validateBtn?.textContent?.includes('Valid&eacute;e')) {
        showLearningWidget({});
    }

    // Add indicators to AI-generated annotations
    document.querySelectorAll('.annotation-item').forEach(annotation => {
        if (annotation.querySelector('.annotation-reasoning')?.textContent?.includes('RLHF')) {
            annotation.classList.add('ai-generated');
            const indicator = document.createElement('div');
            indicator.className = 'rlhf-indicator';
            indicator.innerHTML = '<i class="fas fa-brain"></i> IA Apprenante';
            annotation.appendChild(indicator);
        }
    });

    // Context menu functionality
    addContextMenuToButtons();

    // Hide context menu when clicking elsewhere
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.context-menu')) {
            hideContextMenu();
        }
    });

    // Prevent default context menu on annotation buttons
    document.addEventListener('contextmenu', function(e) {
        if (e.target.classList.contains('label-btn')) {
            e.preventDefault();
        }
    });
}

// ALL YOUR EXISTING FUNCTIONS - Keep everything below exactly as is:

// Regulatory Analysis Functions
function analyzePageRegulatory() {
    const btn = document.getElementById('analyze-page-regulatory-btn');
    const loading = document.getElementById('regulatory-loading');

    btn.disabled = true;
    loading.style.display = 'inline-flex';

    const pageId = document.getElementById('page-text').dataset.pageId;

    fetch(`/regulatory/analyze-page/${pageId}/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showRegulatorySuccess(data.message, data.importance_score);
            // Clear existing annotations visually first, then reload fresh
            setTimeout(() => {
                loadAndRenderAnnotations();
            }, 1000);
        } else {
            alert('Erreur: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Erreur analyse r&eacute;glementaire:', error);
        alert('Erreur lors de l\'analyse r&eacute;glementaire');
    })
    .finally(() => {
        btn.disabled = false;
        loading.style.display = 'none';
    });
}

function analyzeDocumentRegulatory() {
    if (!confirm('Analyser tout le document peut prendre plusieurs minutes. Continuer ?')) {
        return;
    }

    const btn = document.getElementById('analyze-document-regulatory-btn');
    const loading = document.getElementById('regulatory-loading');

    btn.disabled = true;
    loading.style.display = 'inline-flex';
    loading.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyse compl&egrave;te en cours...';

    const documentId = {{ document.id }};

    fetch(`/regulatory/analyze-document/${documentId}/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showRegulatorySuccess(data.message, data.global_score);
            setTimeout(() => location.reload(), 3000);
        } else {
            alert('Erreur: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Erreur analyse document:', error);
        alert('Erreur lors de l\'analyse du document');
    })
    .finally(() => {
        btn.disabled = false;
        loading.style.display = 'none';
        loading.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyse r&eacute;glementaire en cours...';
    });
}

function showRegulatorySuccess(message, score) {
    const successDiv = document.createElement('div');
    successDiv.className = 'validation-success';
    successDiv.innerHTML = `
        <i class="fas fa-balance-scale" style="font-size: 1.5rem;"></i>
        <div>
            <strong> ${message}</strong>
            <div style="font-size: 0.9rem; opacity: 0.9;">Score d'importance: ${score}/100</div>
        </div>
    `;

    const mainContent = document.querySelector('.text-content-card');
    mainContent.parentNode.insertBefore(successDiv, mainContent);

    setTimeout(() => successDiv.remove(), 5000);
}

// JSON Generation Functions
function generatePageJson() {
    const btn = document.getElementById('generate-page-json-btn');
    const loading = document.getElementById('json-loading');

    const annotationsCount = document.querySelectorAll('.inline-annotation').length;
    if (annotationsCount === 0) {
        alert('Aucune annotation trouv&eacute;e sur cette page. Annotez d\'abord la page.');
        return;
    }

    btn.disabled = true;
    loading.style.display = 'inline-flex';

    const pageId = document.getElementById('page-text').dataset.pageId;

    fetch(`/annotation/page/${pageId}/generate-summary/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showJsonSuccess(data.message, 'page');
            setTimeout(() => {
                window.open(`/annotation/page/${pageId}/view-json/`, '_blank');
            }, 1000);
        } else {
            alert('Erreur: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Erreur g&eacute;n&eacute;ration JSON page:', error);
        alert('Erreur lors de la g&eacute;n&eacute;ration du JSON');
    })
    .finally(() => {
        btn.disabled = false;
        loading.style.display = 'none';
    });
}

function generateDocumentJson() {
    const documentId = {{ document.id }};

    if (!confirm('G&eacute;n&eacute;rer le JSON global et le r&eacute;sum&eacute; de tout le document ? Cela peut prendre quelques minutes selon la taille du document.')) {
        return;
    }

    const btn = document.getElementById('generate-document-json-btn');
    const loading = document.getElementById('json-loading');

    btn.disabled = true;
    loading.style.display = 'inline-flex';
    loading.innerHTML = '<i class="fas fa-spinner fa-spin"></i> G&eacute;n&eacute;ration JSON global...';

    fetch(`/annotation/document/${documentId}/generate-summary/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showJsonSuccess(data.message, 'document', data.stats);
            setTimeout(() => {
                window.open(`/annotation/document/${documentId}/view-json/`, '_blank');
            }, 1000);
        } else {
            alert('Erreur: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Erreur g&eacute;n&eacute;ration JSON document:', error);
        alert('Erreur lors de la g&eacute;n&eacute;ration du JSON global');
    })
    .finally(() => {
        btn.disabled = false;
        loading.style.display = 'none';
        loading.innerHTML = '<i class="fas fa-spinner fa-spin"></i> G&eacute;n&eacute;ration JSON...';
    });
}

function showJsonSuccess(message, type, stats = null) {
    const successDiv = document.createElement('div');
    successDiv.className = 'validation-success';

    let statsText = '';
    if (stats) {
        statsText = `<div style="font-size: 0.9rem; opacity: 0.9; margin-top: 0.5rem;">
            ${stats.total_annotations} annotations  ${stats.total_pages} pages
        </div>`;
    }

    const icon = type === 'document' ? 'fas fa-file-contract' : 'fas fa-code';

    successDiv.innerHTML = `
        <i class="${icon}" style="font-size: 1.5rem;"></i>
        <div>
            <strong> ${message}</strong>
            ${statsText}
        </div>
    `;

    const mainContent = document.querySelector('.text-content-card');
    mainContent.parentNode.insertBefore(successDiv, mainContent);

    setTimeout(() => successDiv.remove(), 5000);
}

// AI and Validation Functions
function validatePage() {
    const btn = document.getElementById('validate-page-btn');
    const pageId = document.getElementById('page-text').dataset.pageId;

    if (confirm('Valider cette page ? Cela confirmera que les annotations sont correctes.')) {
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Validation...';

        fetch(`/annotation/validate-page/${pageId}/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const successDiv = document.createElement('div');
                successDiv.className = 'validation-success';
                successDiv.innerHTML = `
                    <i class="fas fa-graduation-cap" style="font-size: 1.5rem;"></i>
                    <div>
                        <strong> ${data.message}</strong>
                        <div style="font-size: 0.9rem; opacity: 0.9;">
                            L'IA s'am&eacute;liore gr&acirc;ce &agrave; votre validation !
                        </div>
                    </div>
                `;

                const mainContent = document.querySelector('.text-content-card');
                mainContent.parentNode.insertBefore(successDiv, mainContent);

                // Toujours afficher le widget d'apprentissage apr&egrave;s validation
                showLearningWidget(data);

                btn.innerHTML = '<i class="fas fa-graduation-cap"></i> Page Valid&eacute;e ';
                btn.disabled = true;

                setTimeout(() => successDiv.remove(), 5000);

            } else {
                alert('Erreur: ' + data.error);
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-graduation-cap"></i> Validate Page';
            }
        })
        .catch(error => {
            console.error('Erreur validation:', error);
            alert('Erreur lors de la validation');
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-graduation-cap"></i> Validate Page';
        });
    }
}

// Learning Widget Functions
function showLearningWidget(data) {
    let widget = document.getElementById('learning-widget') || createLearningWidget();

    fetch('/learning/dashboard/')
        .then(response => response.json())
        .then(learningData => {
            const avgScore = (learningData.average_feedback_score * 100).toFixed(0);
            const {performanceLevel, performanceIcon} = getPerformanceLevel(avgScore);

            widget.innerHTML = `
                <h4><i class="fas fa-chart-line"></i> Progr&egrave;s d'Apprentissage IA</h4>
                <div class="learning-metrics">
                    <div class="metric">
                        <span class="metric-label">Score R&eacute;el:</span>
                        <span class="metric-value">${avgScore}%</span>
                        <span class="performance-indicator">${performanceIcon} ${performanceLevel}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Validations:</span>
                        <span class="metric-value">${learningData.total_feedbacks}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Am&eacute;lioration:</span>
                        <span class="metric-value"> Active</span>
                    </div>
                </div>
                <div class="learning-explanation">
                    <small><i class="fas fa-info-circle"></i> Score bas&eacute; sur annotations correctes, erreurs et manqu&eacute;s</small>
                </div>
            `;
            widget.style.display = 'block';
        })
        .catch(error => {
            console.error('Learning Dashboard Error:', error);
            widget.innerHTML = `
                <h4><i class="fas fa-chart-line"></i> Progr&egrave;s d'Apprentissage</h4>
                <div class="learning-error">
                    <i class="fas fa-exclamation-triangle"></i> Donn&eacute;es non disponibles
                </div>
            `;
        });
}

function deleteAnnotationAndUpdateJSON(annotationId) {
    const structuredArea = document.getElementById('structured-annotation-area');
    const rawArea = document.getElementById('page-text');
    const structuredScrollTop = structuredArea ? structuredArea.scrollTop : null;
    const structuredScrollLeft = structuredArea ? structuredArea.scrollLeft : null;
    const rawScrollTop = rawArea ? rawArea.scrollTop : null;

    fetch(`/annotation/${annotationId}/delete/`, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            const ann = document.querySelector(`.inline-annotation[data-annotation-id="${annotationId}"]`);
            if (ann) {
                const text = ann.getAttribute('data-original-text') || ann.textContent.replace(/\[.*?\]/, '');
                ann.replaceWith(document.createTextNode(text));
            }

            if (structuredArea !== null && structuredScrollTop !== null) {
                structuredArea.scrollTop = structuredScrollTop;
                if (structuredScrollLeft !== null) {
                    structuredArea.scrollLeft = structuredScrollLeft;
                }
            }

            if (rawArea !== null && rawScrollTop !== null) {
                rawArea.scrollTop = rawScrollTop;
            }

            loadVisualAnnotations();
            addAnnotationEventListeners();
        }
    });
}

function createLearningWidget() {
    const widget = document.createElement('section');
    widget.id = 'learning-widget';
    widget.className = 'learning-dashboard-widget';
    document.querySelector('.text-content-card')?.appendChild(widget);
    return widget;
}

function getPerformanceLevel(score) {
    score = parseInt(score);
    if (score >= 90) return {performanceLevel: 'Excellent', performanceIcon: ''};
    if (score >= 75) return {performanceLevel: 'Bon', performanceIcon: ''};
    if (score >= 50) return {performanceLevel: 'Apprentissage', performanceIcon: ''};
    return {performanceLevel: 'N&eacute;cessite entrainement', performanceIcon: ''};
}

// Context Menu Functions
function addContextMenuToButtons() {
    document.querySelectorAll('.label-btn').forEach(btn => {
        // Remove existing listeners to prevent duplicates
        btn.removeEventListener('contextmenu', handleRightClick);
        // Add new listener only to annotation type buttons
        if (!btn.classList.contains('annotation-type-btn-add') && btn.id !== 'clear-annotations-btn') {
            btn.addEventListener('contextmenu', handleRightClick);
        }
    });
}

function annotateWithGroq() {
    const btn = document.getElementById('groq-annotate-btn');
    const loading = document.getElementById('ai-loading');
    const pageId = document.getElementById('page-text').dataset.pageId;

    if (confirm('Lancer l\'annotation automatique avec IA ? Cela remplacera les annotations existantes.')) {
        btn.disabled = true;
        loading.style.display = 'inline-flex';

        fetch(`/annotation/groq/${pageId}/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                mode: 'structured'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const successDiv = document.createElement('div');
                successDiv.className = 'validation-success';
                successDiv.innerHTML = `
                    <i class="fas fa-rocket" style="font-size: 1.5rem;"></i>
                    <div>
                        <strong> ${data.message}</strong>
                        <div style="font-size: 0.9rem; opacity: 0.9;">
                            IA am&eacute;lior&eacute;e par l'apprentissage RLHF
                        </div>
                    </div>
                `;

                const mainContent = document.querySelector('.text-content-card');
                mainContent.parentNode.insertBefore(successDiv, mainContent);

                // Reload raw text annotations
                setTimeout(() => {
                    loadAndRenderAnnotations();
                }, 500);

                // Apply to structured content
                if (data.annotations && data.annotations.length > 0) {
                    data.annotations.forEach(ann => {
                        addAnnotationToStructuredContent(ann);
                    });
                }

            } else {
                alert('Erreur: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Erreur annotation IA:', error);
            alert('Erreur lors de l\'annotation IA');
        })
        .finally(() => {
            btn.disabled = false;
            loading.style.display = 'none';
        });
    }
}


function deleteAnnotation(annotationId) {
    fetch(`/annotation/${annotationId}/delete/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken')
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reload annotations instead of full page
            loadAndRenderAnnotations();

            // Also update the annotations list if it exists
            const annotationElement = document.querySelector(`[data-annotation-id="${annotationId}"]`);
            if (annotationElement) {
                annotationElement.remove();
            }
        } else {
            alert('Erreur: ' + data.error);
        }
    });
}

// Utility Functions
function goToPage(pageNumber) {
    window.location.href = `?page=${pageNumber}`;
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function submitDocumentForExpert() {
    if (confirm('Soumettre ce document complet pour r&eacute;vision expert ? Le JSON global sera g&eacute;n&eacute;r&eacute; automatiquement.')) {
        const documentId = {{ document.id }};
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
        const btn = document.getElementById('submit-document-expert-btn');

        // D&eacute;sactiver le bouton et afficher le chargement
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> G&eacute;n&eacute;ration JSON et soumission...';

        // tape 1: G&eacute;n&eacute;rer le JSON global automatiquement
        console.log(' G&eacute;n&eacute;ration automatique du JSON global avant soumission...');

        fetch(`/annotation/document/${documentId}/generate-summary/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log(' JSON global g&eacute;n&eacute;r&eacute; avec succ&egrave;s');

                // tape 2: Soumettre le document &agrave; l'expert
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Soumission &agrave; l\'expert...';

                return fetch(`/submit-for-expert/${documentId}/`, {
                    method: 'POST',
                    headers: { 'X-CSRFToken': csrfToken }
                });
            } else {
                throw new Error(data.error || 'Erreur lors de la g&eacute;n&eacute;ration du JSON global');
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert(' JSON global g&eacute;n&eacute;r&eacute; et document soumis &agrave; l\'expert avec succ&egrave;s !');
                location.reload();
            } else {
                throw new Error(data.error || 'Erreur lors de la soumission &agrave; l\'expert');
            }
        })
        .catch(error => {
            console.error('Erreur:', error);
            alert('Erreur: ' + error.message);

            // R&eacute;activer le bouton en cas d'erreur
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-user-graduate"></i> Soumission &agrave; l\'Expert';
        });
    }
}

// Modal Functions
function showAddAnnotationTypeModal() {
    document.getElementById('new-annotation-display-name').value = '';
    document.getElementById('new-annotation-name').value = '';

    const modal = new bootstrap.Modal(document.getElementById('addAnnotationTypeModal'), {
        backdrop: true,
        keyboard: true,
        focus: true
    });
    modal.show();
}

function createAnnotationType() {
    const displayName = document.getElementById('new-annotation-display-name').value.trim();
    const name = document.getElementById('new-annotation-name').value.trim();

    if (!displayName) {
        alert('Please enter a display name');
        return;
    }

    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

    fetch('/create-annotation-type/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            display_name: displayName,
            name: name
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert(data.message);

            annotationTypeMap[data.annotation_type.name] = data.annotation_type.id;
            console.log(' Updated type mapping:', annotationTypeMap);

            addNewAnnotationButtonToAnnotateur(data.annotation_type);

            const modalElement = document.getElementById('addAnnotationTypeModal');
            const modal = bootstrap.Modal.getInstance(modalElement);
            if (modal) {
                modal.hide();
            }

            document.getElementById('new-annotation-display-name').value = '';
            document.getElementById('new-annotation-name').value = '';
        } else {
            alert('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error creating annotation type');
    });
}

function addNewAnnotationButtonToAnnotateur(annotationType) {
    // V&eacute;rifier si un bouton avec ce nom existe d&eacute;j&agrave; (en utilisant data-name)
    const existingButton = document.querySelector(`[data-name="${annotationType.name}"]`);
    if (existingButton && !existingButton.classList.contains('annotation-type-btn-add')) {
        console.log('Button already exists for type:', annotationType.name);
        return;
    }

    annotationTypeMap[annotationType.name] = annotationType.id;

    const newButton = document.createElement('button');
    newButton.className = 'label-btn';
    newButton.setAttribute('data-id', annotationType.id);
    newButton.setAttribute('data-name', annotationType.name);
    newButton.setAttribute('data-color', annotationType.color);
    newButton.style.background = annotationType.color;
    newButton.textContent = annotationType.display_name;

    // Add event listeners
    newButton.addEventListener('click', function() {
        document.querySelectorAll('.label-btn').forEach(b => b.classList.remove('active'));

        if (this.id !== 'clear-annotations-btn' && !this.classList.contains('annotation-type-btn-add')) {
            this.classList.add('active');
            currentLabel = {
                id: this.dataset.id,
                name: this.dataset.name,
                color: this.dataset.color
            };
            selectedAnnotationType = this.dataset.name;
            selectedColor = this.dataset.color;
        }
    });

    newButton.addEventListener('contextmenu', handleRightClick);

    const container = document.getElementById('label-toolbar');
    const addButton = document.querySelector('.annotation-type-btn-add');
    if (container && addButton) {
        container.insertBefore(newButton, addButton);
        console.log(` Nouveau type d'annotation "${annotationType.display_name}" ajout&eacute; &agrave; la toolbar`);
    } else {
        console.error(' Impossible de trouver la toolbar ou le bouton d\'ajout');
    }
}

function handleRightClick(e) {
    e.preventDefault();

    // Don't show context menu for special buttons
    if (e.target.classList.contains('annotation-type-btn-add') || e.target.id === 'clear-annotations-btn') {
        return;
    }

    contextMenuTarget = e.target;

    const contextMenu = document.getElementById('context-menu');

    // Position the context menu
    contextMenu.style.left = (e.pageX) + 'px';
    contextMenu.style.top = (e.pageY) + 'px';

    // Show the menu
    contextMenu.classList.remove('hidden');

    console.log('Right-clicked on:', e.target.textContent);
}

function hideContextMenu() {
    const contextMenu = document.getElementById('context-menu');
    contextMenu.classList.add('hidden');
    contextMenuTarget = null;
}

function deleteAnnotationTypeFromMenu() {
    if (!contextMenuTarget) {
        hideContextMenu();
        return;
    }

    const typeName = contextMenuTarget.dataset.name;
    const displayName = contextMenuTarget.textContent;

    // Confirm deletion
    if (!confirm(`Are you sure you want to delete the annotation type "${displayName}"?\n\nThis action cannot be undone.`)) {
        hideContextMenu();
        return;
    }

    console.log('Deleting annotation type:', typeName);

    // Get the annotation type ID
    const typeId = contextMenuTarget.dataset.id;
    if (!typeId) {
        alert('Error: Could not find annotation type to delete');
        hideContextMenu();
        return;
    }

    // Call backend to delete the annotation type
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

    fetch('/delete-annotation-type/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            type_id: typeId,
            type_name: typeName
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert(data.message);

            // Remove from mapping
            delete annotationTypeMap[typeName];
            console.log('Updated type mapping after deletion:', annotationTypeMap);

            // Remove the button from interface
            contextMenuTarget.remove();

            // Clear selection if this type was selected
            if (selectedAnnotationType === typeName) {
                selectedAnnotationType = null;
                selectedColor = null;
                currentLabel = null;
            }

            console.log('Annotation type deleted successfully');
        } else {
            alert('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error deleting annotation type: ' + error.message);
    })
    .finally(() => {
        hideContextMenu();
    });
}

// Document Viewer Function
function viewOriginalDocument(documentId) {
    if (!documentId) {
        alert('Document ID non disponible');
        return;
    }

    const documentUrl = `/documents/${documentId}/view-original/`;
    window.open(documentUrl, '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
}

// Text Highlighting Functions
function highlightTextInDocument(text, startPos, endPos) {
    const pageDisplay = document.getElementById('page-text');
    const originalTextContent = pageDisplay.textContent;

    clearExistingHighlights();

    try {
        pageDisplay.textContent = originalTextContent;

        let content = pageDisplay.textContent;
        let targetText = text.trim();
        let textIndex = -1;
        let foundText = targetText;

        // Strategy 1: Exact match
        textIndex = content.indexOf(targetText);

        // Strategy 2: Case insensitive
        if (textIndex === -1) {
            textIndex = content.toLowerCase().indexOf(targetText.toLowerCase());
        }

        // Strategy 3: Flexible whitespace
        if (textIndex === -1) {
            const flexiblePattern = targetText.replace(/\s+/g, '\\s+');
            const regex = new RegExp(flexiblePattern, 'i');
            const match = content.match(regex);

            if (match) {
                textIndex = content.search(regex);
                foundText = match[0];
            }
        }

        // Strategy 4: Word-by-word fuzzy matching
        if (textIndex === -1) {
            const targetWords = targetText.toLowerCase().split(/\s+/);
            const contentLower = content.toLowerCase();

            const firstWordIndex = contentLower.indexOf(targetWords[0]);
            if (firstWordIndex !== -1) {
                let currentPos = firstWordIndex;
                let matchedText = '';
                let allWordsFound = true;

                for (let word of targetWords) {
                    const wordPos = contentLower.indexOf(word, currentPos);
                    if (wordPos !== -1 && wordPos - currentPos < 100) {
                        if (!matchedText) {
                            matchedText = content.substring(firstWordIndex, wordPos + word.length);
                        } else {
                            matchedText = content.substring(firstWordIndex, wordPos + word.length);
                        }
                        currentPos = wordPos + word.length;
                    } else {
                        allWordsFound = false;
                        break;
                    }
                }

                if (allWordsFound && matchedText) {
                    textIndex = firstWordIndex;
                    foundText = matchedText;
                }
            }
        }

        // Highlight the result
        if (textIndex !== -1) {
            console.log(`Found: "${foundText}" at position ${textIndex}`);

            const beforeText = content.substring(0, textIndex);
            const highlightedText = content.substring(textIndex, textIndex + foundText.length);
            const afterText = content.substring(textIndex + foundText.length);

            pageDisplay.innerHTML =
                beforeText +
                '<span id="highlighted-annotation" style="background-color: #fff3cd; padding: 2px 4px; border-radius: 3px; border: 2px solid #ffc107; animation: highlight-pulse 2s ease-in-out;">' +
                highlightedText +
                '</span>' +
                afterText;

            document.getElementById('highlighted-annotation').scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });

            if (window.highlightTimeout) {
                clearTimeout(window.highlightTimeout);
            }

            window.highlightTimeout = setTimeout(() => {
                pageDisplay.textContent = originalTextContent;
            }, 5000);

        } else {
            console.log('No match found for:', targetText);
            alert('Texte non trouv&eacute;: "' + targetText.substring(0, 50) + (targetText.length > 50 ? '...' : '') + '"');
        }
    } catch (error) {
        console.error('Error highlighting text:', error);
        pageDisplay.textContent = originalTextContent;
    }
}

function clearExistingHighlights() {
    if (window.highlightTimeout) {
        clearTimeout(window.highlightTimeout);
    }

    const existingHighlight = document.getElementById('highlighted-annotation');
    if (existingHighlight) {
        const parent = existingHighlight.parentNode;
        parent.replaceChild(document.createTextNode(existingHighlight.textContent), existingHighlight);
        parent.normalize();
    }
}

// Edit Annotation Functions
function openEditAnnotationModal(annotationId) {
    console.log('Opening edit modal for annotation:', annotationId);

    if (!editModal) {
        alert('Modal d\'&eacute;dition non disponible');
        return;
    }

    currentEditingAnnotationId = annotationId;
    loadAnnotationDetails(annotationId);
}

function loadAnnotationDetails(annotationId) {
    showEditModalLoading(true);

    fetch(`/annotation/${annotationId}/details/`, {
        method: 'GET',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            populateEditModal(data.annotation);
            editModal.show();
        } else {
            alert('Erreur lors du chargement des d&eacute;tails: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Erreur chargement annotation:', error);
        alert('Erreur lors du chargement des d&eacute;tails de l\'annotation');
    })
    .finally(() => {
        showEditModalLoading(false);
    });
}

function populateEditModal(annotation) {
    const selectedTextField = document.getElementById('edit-selected-text');
    const annotationTypeField = document.getElementById('edit-annotation-type');

    if (selectedTextField) {
        selectedTextField.value = annotation.selected_text || '';
    }

    if (annotationTypeField) {
        const lockedTypeId = annotation.annotation_type?.id ?? '';
        annotationTypeField.value = lockedTypeId;
        annotationTypeField.dataset.lockedTypeId = lockedTypeId;
        annotationTypeField.disabled = true;
        annotationTypeField.classList.add('annotation-type-readonly');
    }

    document.getElementById('edit-start-pos').value = annotation.start_pos || '';
    document.getElementById('edit-end-pos').value = annotation.end_pos || '';

    document.getElementById('edit-created-by').textContent = annotation.created_by || 'IA';
    document.getElementById('edit-confidence').textContent = Math.round(annotation.confidence_score || 0);
    document.getElementById('edit-ai-reasoning').textContent = annotation.ai_reasoning || 'Aucun raisonnement disponible';

    if (annotation.modified_by_human) {
        const infoPanel = document.querySelector('.annotation-info-panel');
        if (infoPanel) {
            infoPanel.style.borderLeft = '4px solid var(--pharma-accent)';
            infoPanel.style.backgroundColor = '#f0fdf4';
        }
    }

    console.log('Modal populated with annotation data');
}

function saveAnnotationChanges() {
    if (!currentEditingAnnotationId) {
        alert('Aucune annotation s&eacute;lectionn&eacute;e pour modification');
        return;
    }

    const selectedText = document.getElementById('edit-selected-text').value.trim();
    const typeField = document.getElementById('edit-annotation-type');
    const annotationTypeId = typeField?.dataset?.lockedTypeId || typeField?.value || '';
    const startPos = parseInt(document.getElementById('edit-start-pos').value) || 0;
    const endPos = parseInt(document.getElementById('edit-end-pos').value) || 0;

    if (!selectedText) {
        alert('Le texte s&eacute;lectionn&eacute; ne peut pas &ecirc;tre vide');
        return;
    }

    if (!annotationTypeId) {
        alert('Type d\'annotation manquant pour cette annotation');
        return;
    }

    const editData = {
        selected_text: selectedText,
        annotation_type_id: annotationTypeId,
        start_pos: startPos,
        end_pos: endPos
    };

    const saveButton = document.querySelector('#editAnnotationModal .btn-primary');
    const originalText = saveButton.innerHTML;
    saveButton.disabled = true;
    saveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...';

    fetch(`/annotation/${currentEditingAnnotationId}/edit/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(editData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showEditSuccess(data.message);
            editModal.hide();
            updateAnnotationInList(data.annotation);
            currentEditingAnnotationId = null;

            // Reload inline annotations to show changes
            setTimeout(() => {
                loadAndRenderAnnotations();
            }, 500);
        } else {
            alert('Erreur lors de la sauvegarde: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Erreur sauvegarde annotation:', error);
        alert('Erreur lors de la sauvegarde des modifications');
    })
    .finally(() => {
        saveButton.disabled = false;
        saveButton.innerHTML = originalText;
    });
}

function updateAnnotationInList(updatedAnnotation) {
    const annotationElement = document.querySelector(`[data-annotation-id="${updatedAnnotation.id}"]`);
    if (!annotationElement) {
        console.error('Annotation element not found in list');
        return;
    }

    const typeElement = annotationElement.querySelector('.annotation-type');
    if (typeElement) {
        typeElement.textContent = updatedAnnotation.annotation_type.display_name;
        typeElement.style.background = updatedAnnotation.annotation_type.color;
    }

    const textElement = annotationElement.querySelector('.annotation-text');
    if (textElement) {
        textElement.textContent = `"${updatedAnnotation.selected_text}"`;
        textElement.onclick = function() {
            highlightTextInDocument(
                updatedAnnotation.selected_text,
                updatedAnnotation.start_pos,
                updatedAnnotation.end_pos
            );
        };
    }

    let humanIndicator = annotationElement.querySelector('.human-modified-indicator');
    if (!humanIndicator) {
        humanIndicator = document.createElement('div');
        humanIndicator.className = 'human-modified-indicator';
        annotationElement.appendChild(humanIndicator);
    }
    humanIndicator.innerHTML = '<i class="fas fa-user-edit"></i> Modifi&eacute; par vous';

    annotationElement.style.animation = 'highlight-pulse 1s ease-in-out';
    setTimeout(() => {
        annotationElement.style.animation = '';
    }, 1000);

    console.log('Annotation updated in list');
}

function showEditSuccess(message) {
    const successDiv = document.createElement('div');
    successDiv.className = 'validation-success';
    successDiv.innerHTML = `
        <i class="fas fa-edit" style="font-size: 1.5rem;"></i>
        <div>
            <strong> ${message}</strong>
            <div style="font-size: 0.9rem; opacity: 0.9;">
                L'annotation a &eacute;t&eacute; mise &agrave; jour avec vos corrections
            </div>
        </div>
    `;

    const mainContent = document.querySelector('.text-content-card');
    if (mainContent) {
        mainContent.parentNode.insertBefore(successDiv, mainContent);
        setTimeout(() => successDiv.remove(), 4000);
    }
}

function showEditModalLoading(show) {
    console.log(show ? 'Loading...' : 'Loading complete');
}

function resetEditModal() {
    document.getElementById('edit-selected-text').value = '';
    const typeField = document.getElementById('edit-annotation-type');
    if (typeField) {
        typeField.value = '';
        delete typeField.dataset.lockedTypeId;
        typeField.disabled = true;
        typeField.classList.add('annotation-type-readonly');
    }
    document.getElementById('edit-start-pos').value = '';
    document.getElementById('edit-end-pos').value = '';
    document.getElementById('edit-created-by').textContent = '-';
    document.getElementById('edit-confidence').textContent = '-';
    document.getElementById('edit-ai-reasoning').textContent = '-';

    const infoPanel = document.querySelector('.annotation-info-panel');
    if (infoPanel) {
        infoPanel.style.borderLeft = '1px solid #dee2e6';
        infoPanel.style.backgroundColor = '#f8f9fa';
    }

    currentEditingAnnotationId = null;
}

// Event listener for modal close
document.addEventListener('DOMContentLoaded', function() {
    const editModalElement = document.getElementById('editAnnotationModal');
    if (editModalElement) {
        editModalElement.addEventListener('hidden.bs.modal', function() {
            resetEditModal();
        });
    }
});

function recalculatePositions() {
    const selectedText = document.getElementById('edit-selected-text').value.trim();
    const pageText = document.getElementById('page-text').textContent;

    if (selectedText && pageText) {
        const startPos = pageText.indexOf(selectedText);
        if (startPos !== -1) {
            document.getElementById('edit-start-pos').value = startPos;
            document.getElementById('edit-end-pos').value = startPos + selectedText.length;
        }
    }
}

// Auto-recalculate positions when text changes
document.addEventListener('DOMContentLoaded', function() {
    const textArea = document.getElementById('edit-selected-text');
    if (textArea) {
        textArea.addEventListener('blur', recalculatePositions);
    }
});

/**
 * Charge automatiquement les types d'annotation Llama depuis le cache si disponibles
 */
function loadLlamaCachedTypes() {
    console.log(" V&eacute;rification du cache Llama...");

    // V&eacute;rifier si le cache Llama existe c&ocirc;t&eacute; serveur
    if (LLAMA_CACHE_EXISTS && LLAMA_CACHED_TYPES && LLAMA_CACHED_TYPES.length > 0) {
        console.log(" Cache Llama trouv&eacute; c&ocirc;t&eacute; serveur, ajout des types existants");

        // V&eacute;rifier si la barre d'outils existe
        var toolbar = document.getElementById('label-toolbar');
        if (!toolbar) {
            console.log("? Barre d'outils non trouv&eacute;e, Llama sera charg&eacute; plus tard");
            return;
        }

        // Ajouter les types Llama &agrave; la barre d'outils existante (sans vider)
        LLAMA_CACHED_TYPES.forEach(function(type) {
            // V&eacute;rifier si le type n'existe pas d&eacute;j&agrave;
            var existingButton = toolbar.querySelector(`[data-name="${type.name}"]`);
            if (existingButton) {
                console.log(`Type ${type.name} d&eacute;j&agrave; pr&eacute;sent, ignor&eacute;`);
                return;
            }

            var button = document.createElement('button');
            button.className = 'label-btn';
            button.dataset.id = type.id;
            button.dataset.name = type.name;
            button.dataset.color = type.color;
            button.style.background = type.color;
            button.textContent = type.display_name;
            button.title = `${type.display_name} (Llama)`;

            button.addEventListener('click', function() {
                document.querySelectorAll('.label-btn').forEach(function(b) {
                    b.classList.remove('active');
                });

                button.classList.add('active');
                currentLabel = {
                    id: button.dataset.id,
                    name: button.dataset.name,
                    color: button.dataset.color
                };
            });

            // Ins&eacute;rer avant les boutons sp&eacute;ciaux (Add Custom Type et Clear)
            var addButton = toolbar.querySelector('.annotation-type-btn-add');
            if (addButton) {
                toolbar.insertBefore(button, addButton);
            } else {
                toolbar.appendChild(button);
            }

            annotationTypeMap[type.name] = type.id;
        });

        // Afficher une notification discr&egrave;te
        var cacheDiv = document.createElement('div');
        cacheDiv.className = 'validation-success';
        cacheDiv.innerHTML = '<i class="fas fa-robot" style="font-size: 1.5rem;"></i>' +
            '<div><strong> Types d\'annotation Llama restaur&eacute;s</strong>' +
            '<div style="font-size: 0.9rem; opacity: 0.9;">' +
            'Llama avait sugg&eacute;r&eacute; ' + LLAMA_CACHED_TYPES.length + ' types pour ce document' +
            '</div></div>';

        var mainContent = document.querySelector('.text-content-card');
        if (mainContent) {
            mainContent.parentNode.insertBefore(cacheDiv, mainContent);
            setTimeout(function() {
                cacheDiv.remove();
            }, 3000);
        }

        console.log(` ${LLAMA_CACHED_TYPES.length} types d'annotation Llama ajout&eacute;s`);
    } else {
        console.log("? Pas de cache Llama trouv&eacute; pour ce document");
    }
}

/**
 * V&eacute;rifie d'abord le cache Mistral c&ocirc;t&eacute; serveur avant de lancer une nouvelle analyse
 * Ceci &eacute;vite de relancer Mistral &agrave; chaque rechargement de page
 */
function checkMistralCacheAndLoad() {
    console.log(" V&eacute;rification du cache Mistral...");

    // Cl&eacute; unique pour ce document
    var cacheKey = 'mistral_analyzed_' + DOCUMENT_ID;
    var cachedAnalysis = localStorage.getItem(cacheKey);

    // V&eacute;rifier d'abord le localStorage (cache c&ocirc;t&eacute; client)
    if (cachedAnalysis) {
        console.log(" Cache Mistral trouv&eacute; dans localStorage, pas de nouvelle analyse");
        try {
            var analysisData = JSON.parse(cachedAnalysis);
            if (analysisData.entity_types && analysisData.entity_types.length > 0) {
                updateToolbarWithMistralTypes(analysisData.entity_types);

                // Afficher notification depuis cache localStorage
                var cacheDiv = document.createElement('div');
                cacheDiv.className = 'validation-success';
                cacheDiv.innerHTML = '<i class="fas fa-brain" style="font-size: 1.5rem;"></i>' +
                    '<div><strong>Types d\'annotation personnalis&eacute;s (cache)</strong>' +
                    '<div style="font-size: 0.9rem; opacity: 0.9;">' +
                    'Mistral : ' + analysisData.entity_types.length + ' types sp&eacute;cialis&eacute;s en ' + (analysisData.language || 'fr') +
                    '</div></div>';

                var mainContent = document.querySelector('.text-content-card');
                if (mainContent) {
                    mainContent.parentNode.insertBefore(cacheDiv, mainContent);
                    setTimeout(function() {
                        cacheDiv.remove();
                    }, 3000);
                }
                return; // Arr&ecirc;ter ici, ne pas faire d'appel API
            }
        } catch (e) {
            console.log("? Erreur lors de la lecture du cache localStorage, suppression...");
            localStorage.removeItem(cacheKey);
        }
    }

    // V&eacute;rifier ensuite le cache c&ocirc;t&eacute; serveur (variables pass&eacute;es du template)
    if (MISTRAL_CACHE_EXISTS && MISTRAL_CACHED_TYPES && MISTRAL_CACHED_TYPES.length > 0) {
        console.log(" Cache Mistral trouv&eacute; c&ocirc;t&eacute; serveur, utilisation des donn&eacute;es existantes");

        // Sauvegarder dans localStorage pour les prochains rechargements
        var analysisData = {
            entity_types: MISTRAL_CACHED_TYPES,
            language: MISTRAL_DOCUMENT_LANGUAGE,
            domain: MISTRAL_DOCUMENT_DOMAIN,
            cached_at: new Date().toISOString()
        };
        localStorage.setItem(cacheKey, JSON.stringify(analysisData));

        // Utiliser directement les types du cache
        updateToolbarWithMistralTypes(MISTRAL_CACHED_TYPES);

        // Afficher une notification discr&egrave;te
        var cacheDiv = document.createElement('div');
        cacheDiv.className = 'validation-success';
        cacheDiv.innerHTML = '<i class="fas fa-brain" style="font-size: 1.5rem;"></i>' +
            '<div><strong>  Types d\'annotation personnalis&eacute;s charg&eacute;s</strong>' +
            '<div style="font-size: 0.9rem; opacity: 0.9;">' +
            'Mistral a remplac&eacute; les types par d&eacute;faut par ' + MISTRAL_CACHED_TYPES.length + ' types sp&eacute;cialis&eacute;s (' + MISTRAL_DOCUMENT_LANGUAGE + ')' +
            '</div></div>';

        var mainContent = document.querySelector('.text-content-card');
        if (mainContent) {
            mainContent.parentNode.insertBefore(cacheDiv, mainContent);
            setTimeout(function() {
                cacheDiv.remove();
            }, 3000);
        }

        return; // Important: arr&ecirc;ter ici, ne pas faire d'appel API
    }

    // Pas de cache c&ocirc;t&eacute; serveur, lancer une nouvelle analyse automatiquement
    console.log(" Pas de cache Mistral trouv&eacute;, lancement d'une nouvelle analyse automatique");
    loadMistralAnnotationTypes();
}

/**
 * Fonction pour charger automatiquement les types d'annotation sugg&eacute;r&eacute;s par Mistral
 */
function loadMistralAnnotationTypes() {
    console.log(" Chargement des types d'annotation sugg&eacute;r&eacute;s par Mistral...");

    // Utiliser la variable globale DOCUMENT_ID d&eacute;finie en haut du document

    // Afficher un indicateur de chargement
    var loadingDiv = document.createElement('div');
    loadingDiv.id = 'mistral-loading-indicator';
    loadingDiv.className = 'mistral-loading-indicator';
    loadingDiv.innerHTML = '<div class="spinner-border spinner-border-sm text-primary"></div><span>Chargement des types d\'annotation...</span>';
    loadingDiv.style.position = 'fixed';
    loadingDiv.style.top = '10px';
    loadingDiv.style.right = '10px';
    loadingDiv.style.background = 'rgba(255,255,255,0.9)';
    loadingDiv.style.padding = '10px';
    loadingDiv.style.borderRadius = '5px';
    loadingDiv.style.zIndex = '9999';
    loadingDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
    document.body.appendChild(loadingDiv);

    // Appeler l'API Mistral avec l'ID global
    fetch('/api/mistral/analyze_document/' + DOCUMENT_ID + '/', {
        method: 'GET',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
            if (data.success) {
                var entityCount = data.entity_types ? data.entity_types.length : 0;
                var displayLanguage = data.displayed_language || '';

                console.log(' Mistral a sugg&eacute;r&eacute;', entityCount, 'types d\'annotation en', displayLanguage);

                if (data.entity_types && data.entity_types.length > 0) {
                    // Sauvegarder dans localStorage pour les prochains rechargements
                    var cacheKey = 'mistral_analyzed_' + DOCUMENT_ID;
                    var analysisData = {
                        entity_types: data.entity_types,
                        language: data.displayed_language || 'fr',
                        domain: data.document_domain || '',
                        cached_at: new Date().toISOString()
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(analysisData));
                    console.log(" Sauvegarde du cache Mistral dans localStorage pour document", DOCUMENT_ID);

                    // Mettre &agrave; jour l'interface
                    updateToolbarWithMistralTypes(data.entity_types);

                    // Afficher notification
                    var successDiv = document.createElement('div');
                    successDiv.className = 'validation-success';
                    successDiv.innerHTML = '<i class="fas fa-brain" style="font-size: 1.5rem;"></i>' +
                        '<div><strong> Types d\'annotation personnalis&eacute;s</strong>' +
                        '<div style="font-size: 0.9rem; opacity: 0.9;">' +
                        'Mistral a remplac&eacute; les types par d&eacute;faut par ' + entityCount + ' types sp&eacute;cialis&eacute;s' +
                        (displayLanguage ? ' <span class="badge bg-info" title="Langue d&eacute;tect&eacute;e automatiquement">' + displayLanguage + '</span>' : '') +
                        '</div></div>';

                var mainContent = document.querySelector('.text-content-card');
                if (mainContent) {
                    mainContent.parentNode.insertBefore(successDiv, mainContent);
                    setTimeout(function() {
                        successDiv.remove();
                    }, 5000);
                }
            }
        } else {
            console.error('Erreur lors de l\'analyse Mistral:', data.error);
        }
    })
    .catch(function(error) {
        console.error('Erreur lors de l\'appel &agrave; l\'API Mistral:', error);
    })
    .finally(function() {
        // Supprimer l'indicateur de chargement
        var loadingIndicator = document.getElementById('mistral-loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.remove();
        }
    });
}

/**
 * Met &agrave; jour la barre d'outils avec SEULEMENT les types d'annotation sugg&eacute;r&eacute;s par Mistral
 * REMPLACE tous les types existants (types de base)
 */
function updateToolbarWithMistralTypes(entityTypes) {
    if (!entityTypes || entityTypes.length === 0) return;

    var toolbar = document.getElementById('label-toolbar');
    if (!toolbar) return;

    console.log(' D&eacute;but de updateToolbarWithMistralTypes avec', entityTypes.length, 'types');

    // Sauvegarder SEULEMENT les boutons sp&eacute;ciaux (Add Custom Type et Clear All)
    var specialButtons = [];
    toolbar.querySelectorAll('button').forEach(function(btn) {
        if (btn.classList.contains('annotation-type-btn-add') || btn.id === 'clear-annotations-btn') {
            specialButtons.push(btn.cloneNode(true));
            console.log(' Sauvegarde du bouton sp&eacute;cial:', btn.textContent.trim());
        }
    });

    console.log(' Boutons sp&eacute;ciaux sauvegard&eacute;s:', specialButtons.length);

    // VIDER compl&egrave;tement la barre d'outils pour remplacer par les types Mistral
    toolbar.innerHTML = '';

    // Ajouter SEULEMENT les types sugg&eacute;r&eacute;s par Mistral
    entityTypes.forEach(function(type) {
        var button = document.createElement('button');
        button.className = 'label-btn';
        button.dataset.id = type.id;
        button.dataset.name = type.name;
        button.dataset.color = type.color;
        button.style.background = type.color;
        button.textContent = type.display_name;
        button.title = `${type.display_name} (Mistral AI)`;

        button.addEventListener('click', function() {
            document.querySelectorAll('.label-btn').forEach(function(b) {
                b.classList.remove('active');
            });

            button.classList.add('active');
            currentLabel = {
                id: button.dataset.id,
                name: button.dataset.name,
                color: button.dataset.color
            };
        });

        toolbar.appendChild(button);
        annotationTypeMap[type.name] = type.id;
    });

    specialButtons.forEach(function(btn) {
        var newBtn = document.createElement('button');
        newBtn.className = btn.className;
        newBtn.innerHTML = btn.innerHTML;

        // Copier tous les attributs
        for (var i = 0; i < btn.attributes.length; i++) {
            var attr = btn.attributes[i];
            newBtn.setAttribute(attr.name, attr.value);
        }

        // Attacher les bons &eacute;v&eacute;nements
        if (btn.classList.contains('annotation-type-btn-add')) {
            newBtn.onclick = showAddAnnotationTypeModal;
            newBtn.setAttribute('data-bs-toggle', 'modal');
            newBtn.setAttribute('data-bs-target', '#addAnnotationTypeModal');
        } else if (btn.id === 'clear-annotations-btn') {
            newBtn.addEventListener('click', function() {
                if (confirm('tes-vous s&ucirc;r de vouloir effacer toutes les annotations de cette page?')) {
                    clearAllAnnotations();
                }
            });
        }

        toolbar.appendChild(newBtn);
        console.log(' Bouton sp&eacute;cial restaur&eacute;:', newBtn.textContent.trim());
    });

    console.log(` Barre d'outils remplac&eacute;e par ${entityTypes.length} types d'annotation Mistral uniquement`);
}

// Event listener pour la g&eacute;n&eacute;ration automatique du nom technique
document.addEventListener('DOMContentLoaded', function() {
    const displayNameInput = document.getElementById('new-annotation-display-name');
    const nameInput = document.getElementById('new-annotation-name');

    if (displayNameInput && nameInput) {
        displayNameInput.addEventListener('input', function() {
            // G&eacute;n&eacute;rer automatiquement le nom technique &agrave; partir du nom d'affichage
            const displayName = this.value.trim();
            const technicalName = displayName
                .toLowerCase()
                .replace(/[^a-zA-Z0-9\s]/g, '') // Enlever les caract&egrave;res sp&eacute;ciaux
                .replace(/\s+/g, '_') // Remplacer les espaces par des underscores
                .substring(0, 50); // Limiter la longueur

            nameInput.value = technicalName;
        });
    }
});

console.log('Prodigy-like annotation system with full functionality loaded successfully');


// Split Screen with Real-Time JSON Preview
let scrollSyncEnabled = true;
let isUpdating = false;
let currentJSONTab = 'page';

document.addEventListener('DOMContentLoaded', function() {
    initializeSplitScreen();
    setupRealtimeSync();
    loadInitialJSON();
});

function initializeSplitScreen() {
    const leftBody = document.getElementById('left-panel-body');
    const rightBody = document.getElementById('right-panel-body');

    if (!leftBody || !rightBody) return;

    leftBody.addEventListener('scroll', function() {
        if (scrollSyncEnabled && !isUpdating) {
            isUpdating = true;
            rightBody.scrollTop = this.scrollTop;
            showSyncIndicator();
            setTimeout(() => isUpdating = false, 100);
        }
    });
}

function setupRealtimeSync() {
    const leftArea = document.getElementById('structured-annotation-area');
    if (!leftArea) return;

    let updateTimeout;
    const observer = new MutationObserver(function(mutations) {
        // Clear existing timeout to debounce rapid changes
        clearTimeout(updateTimeout);

        // Wait 500ms after the last change before updating JSON
        updateTimeout = setTimeout(() => {
            console.log(' Syncing JSON after changes...');
            updateExpertJSON();
        }, 500);
    });

    observer.observe(leftArea, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
    });
}

function loadInitialJSON() {
    const pageId = document.getElementById('structured-annotation-area')?.dataset.pageId;
    if (pageId) {
        loadPageJSON(pageId);
    }
    loadDocumentJSON();
}

let isCodeMode = false;

function toggleJSONMode() {
    isCodeMode = !isCodeMode;
    const visualEditor = document.getElementById('visual-json-editor');
    const codeEditor = document.getElementById('page-json-display');
    const btn = event.currentTarget;
    const icon = btn.querySelector('i');

    if (isCodeMode) {
        // Switch to code mode
        visualEditor.style.display = 'none';
        codeEditor.style.display = 'block';
        icon.className = 'fas fa-list';
        btn.title = 'Mode Simple';

        // Make code editable
        makeJSONEditable('page-json-display');
    } else {
        // Switch to visual mode
        visualEditor.style.display = 'block';
        codeEditor.style.display = 'none';
        icon.className = 'fas fa-code';
        btn.title = 'Mode Code';

        // Reload visual editor
        loadVisualAnnotations();
    }
}

function loadVisualAnnotations() {
    const pageId = document.getElementById('structured-annotation-area')?.dataset.pageId;
    if (!pageId) return;

    fetch(`/annotation/page/${pageId}/`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // SHOW ALL ANNOTATIONS (backward compatibility)
                displayVisualAnnotations(data.annotations);
                document.getElementById('page-annotations-count').textContent = data.annotations.length;
            }
        });
}

function displayVisualAnnotations(annotations) {
    const container = document.getElementById('visual-annotations-list');
    if (!container) return;

    const previousScrollTop = container.scrollTop;
    const previousScrollLeft = container.scrollLeft;

    if (!annotations || annotations.length === 0) {
        container.innerHTML = `
            <div class="empty-annotations">
                <i class="fas fa-inbox"></i>
                <p>Aucune annotation</p>
            </div>
        `;
        container.scrollTop = previousScrollTop;
        container.scrollLeft = previousScrollLeft;
        return;
    }

    // Check which annotations actually exist in structured content
    const structuredArea = document.getElementById('structured-annotation-area');
    const existingIds = new Set();

    if (structuredArea) {
        structuredArea.querySelectorAll('.inline-annotation[data-annotation-id]').forEach(el => {
            const id = parseInt(el.dataset.annotationId);
            if (!isNaN(id)) existingIds.add(id);
        });
    }

    console.log(' Annotations in JSON:', annotations.length, '| In structured content:', existingIds.size);

    container.innerHTML = annotations.map(ann => {
        const exists = existingIds.has(ann.id);
        const statusIcon = exists ? '' : '?';
        const statusText = exists ? 'Visible' : 'Fant&ocirc;me';
        const statusColor = exists ? '#10b981' : '#f59e0b';
        const primaryTypeId = (ann.annotation_type && ann.annotation_type.id)
            ? ann.annotation_type.id
            : (ann.annotation_type_id ?? ann.type_id ?? ann.annotation_typeId);
        const rawTypeId = sanitizeTypeId(primaryTypeId);
        const resolvedTypeId = rawTypeId || sanitizeTypeId(getTypeIdFromDisplay(ann.type_display || '', { allowFallback: false })) || '';

        return `
            <div class="annotation-card ${!exists ? 'ghost-annotation' : ''}" data-annotation-id="${ann.id}" data-annotation-type-id="${resolvedTypeId}" data-annotation-type-display="${ann.type_display}">
                <div class="annotation-card-header">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="annotation-id">#${ann.id}</span>
                        <span style="font-size: 0.7rem; color: ${statusColor};" title="${statusText}">
                            ${statusIcon} ${statusText}
                        </span>
                    </div>
                    <div class="annotation-actions">
                        ${!exists ? `
                            <button class="card-btn" onclick="restoreAnnotation(${ann.id})" title="Restaurer dans le document">
                                <i class="fas fa-redo"></i> Restaurer
                            </button>
                        ` : `
                            <button class="card-btn" onclick="editAnnotationVisual(${ann.id})" title="diter">
                                <i class="fas fa-edit"></i>
                            </button>
                        `}
                        <button class="card-btn delete" onclick="deleteAnnotationVisual(${ann.id}, ${exists})" title="Supprimer">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                <div class="annotation-text-display">
                    "${ann.selected_text}"
                </div>
                <span class="annotation-type-badge" style="background: ${ann.color}20; color: ${ann.color}; border: 1px solid ${ann.color}40;" data-annotation-type-id="${resolvedTypeId}">
                    ${ann.type_display}
                </span>
            </div>
        `;
    }).join('');
    container.scrollTop = previousScrollTop;
    container.scrollLeft = previousScrollLeft;
}

function deleteAnnotationVisual(annotationId, existsInContent = true) {
    const typeText = existsInContent ? 'annotation' : 'annotation fant&ocirc;me (d&eacute;j&agrave; supprim&eacute;e du document)';

    if (!confirm(` Supprimer cette ${typeText} ?`)) return;

    // Show loading
    const card = document.querySelector(`[data-annotation-id="${annotationId}"]`);
    if (card) {
        card.style.opacity = '0.5';
        card.style.pointerEvents = 'none';
    }

    // Remove from structured content ONLY if it exists
    if (existsInContent) {
        const structuredAnn = document.querySelector(`.inline-annotation[data-annotation-id="${annotationId}"]`);
        if (structuredAnn) {
            console.log(' Removing highlight from structured content, preserving text');

            // Get ONLY the text (excluding label)
            const labelElement = structuredAnn.querySelector('.ann-label');
            let textContent = '';

            for (let node of structuredAnn.childNodes) {
                if (node.nodeType === Node.TEXT_NODE) {
                    textContent += node.textContent;
                } else if (node !== labelElement && node.nodeType === Node.ELEMENT_NODE) {
                    textContent += node.textContent;
                }
            }

            // Create text node with preserved text
            const textNode = document.createTextNode(textContent);

            // Replace the annotation span with plain text
            structuredAnn.parentNode.replaceChild(textNode, structuredAnn);

            console.log(' Text preserved:', textContent.substring(0, 50));
        }
    } else {
        console.log('? Ghost annotation - only deleting from database');
    }

    // Delete from database
    fetch(`/annotation/${annotationId}/delete/`, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Remove from UI
            if (card) card.remove();

            // Update count
            const count = document.getElementById('page-annotations-count');
            if (count) {
                count.textContent = Math.max(0, parseInt(count.textContent) - 1);
            }

            console.log(' Annotation deleted:', annotationId);

            // Reload to ensure sync
            setTimeout(() => {
                loadVisualAnnotations();
            }, 300);
        } else {
            alert(' Erreur: ' + data.error);
            if (card) {
                card.style.opacity = '1';
                card.style.pointerEvents = 'auto';
            }
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert(' Erreur r&eacute;seau');
        if (card) {
            card.style.opacity = '1';
            card.style.pointerEvents = 'auto';
        }
    });
}

function restoreAnnotation(annotationId) {
    const card = document.querySelector(`[data-annotation-id="${annotationId}"]`);
    if (!card) return;

    const textDisplay = card.querySelector('.annotation-text-display');
    const badge = card.querySelector('.annotation-type-badge');

    if (!textDisplay || !badge) {
        alert(' Impossible de restaurer cette annotation');
        return;
    }

    const text = textDisplay.textContent.replace(/^"|"$/g, '').trim();
    const typeDisplay = badge.textContent.trim();
    const color = badge.style.color || '#ffeb3b';

    console.log(' Restoring annotation:', annotationId, 'Text:', text);

    // Show loading
    card.style.opacity = '0.5';

    // Try to find and highlight the text in structured content
    const structuredArea = document.getElementById('structured-annotation-area');
    if (!structuredArea) {
        alert(' Zone de contenu structur&eacute; introuvable');
        card.style.opacity = '1';
        return;
    }

    // Search for the text
    const walker = document.createTreeWalker(
        structuredArea,
        NodeFilter.SHOW_TEXT,
        {
            acceptNode: function(node) {
                // Skip if already inside an annotation
                let parent = node.parentNode;
                while (parent && parent !== structuredArea) {
                    if (parent.classList && parent.classList.contains('inline-annotation')) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    parent = parent.parentNode;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        }
    );

    let found = false;
    let textNode;

    while (textNode = walker.nextNode()) {
        const nodeText = textNode.textContent;
        const index = nodeText.indexOf(text);

        if (index !== -1) {
            found = true;
            console.log(` Found text at position ${index}`);

            // Split the text node
            const before = nodeText.substring(0, index);
            const match = nodeText.substring(index, index + text.length);
            const after = nodeText.substring(index + text.length);

            // Create annotation span
            const span = document.createElement('span');
            span.className = 'inline-annotation';
            span.dataset.annotationId = annotationId;
            span.style.cssText = `
                background-color: ${color}20;
                color: inherit;
                font-family: inherit;
                font-size: inherit;
                font-weight: inherit;
                padding: 2px 4px;
                margin: 0 1px;
                border-radius: 3px;
                cursor: pointer;
            `;
            span.textContent = match;
            span.setAttribute('data-original-text', match);

            // Add label
            const label = document.createElement('span');
            label.className = 'ann-label';
            label.style.cssText = `
                font-size: 0.7rem;
                font-weight: bold;
                margin-left: 4px;
                padding: 2px 6px;
                border-radius: 4px;
                background: rgba(0,0,0,0.6);
                color: #fff;
                white-space: nowrap;
                display: inline;
                opacity: 1;
            `;
            label.textContent = typeDisplay;
            span.appendChild(label);

            // Add click handler
            span.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                const originalText = this.getAttribute('data-original-text');
                if (originalText) {
                    const textNode = document.createTextNode(originalText);
                    this.parentNode.replaceChild(textNode, this);
                }

                deleteAnnotationAndUpdateJSON(annotationId);
            });

            // Replace the text node
            const parent = textNode.parentNode;
            if (before) parent.insertBefore(document.createTextNode(before), textNode);
            parent.insertBefore(span, textNode);
            if (after) parent.insertBefore(document.createTextNode(after), textNode);
            parent.removeChild(textNode);

            break;
        }
    }

    if (found) {
        alert(' Annotation restaur&eacute;e avec succ&egrave;s !');
        card.style.opacity = '1';

        // Reload visual list to update status
        setTimeout(() => {
            loadVisualAnnotations();
        }, 500);
    } else {
        alert(' Texte introuvable dans le document. L\'annotation reste en "fant&ocirc;me".');
        card.style.opacity = '1';
    }
}


// Helper function to get type ID from display name
function getTypeIdFromDisplay(displayName, { allowFallback = true } = {}) {
    if (!displayName) return null;

    // Search in annotationTypeMap (reverse lookup)
    for (let [name, id] of Object.entries(annotationTypeMap)) {
        const button = document.querySelector(`[data-name="${name}"]`);
        if (button && button.textContent.trim() === displayName) {
            return sanitizeTypeId(button.dataset.id || id);
        }
    }

    // Fallback: search by exact display name in buttons
    const buttons = document.querySelectorAll('.label-btn[data-id]');
    for (let btn of buttons) {
        if (btn.textContent.trim() === displayName) {
            return sanitizeTypeId(btn.dataset.id);
        }
    }

    if (!allowFallback) {
        return null;
    }

    const firstButton = document.querySelector('.label-btn[data-id]');
    return sanitizeTypeId(firstButton ? firstButton.dataset.id : null);
}

function sanitizeTypeId(candidate) {
    if (candidate === undefined || candidate === null) {
        return null;
    }

    const normalized = String(candidate).trim();

    if (!normalized || normalized === 'null' || normalized === 'undefined' || normalized === 'NaN') {
        return null;
    }

    return normalized;
}

function inferAnnotationType(text) {
    // Try to guess the annotation type based on the text content
    const lowerText = text.toLowerCase();

    // Get all available types
    const buttons = document.querySelectorAll('.label-btn[data-name]');

    for (let btn of buttons) {
        const typeName = btn.dataset.name.toLowerCase();
        const displayName = btn.textContent.trim().toLowerCase();

        // Simple matching rules
        if (displayName.includes('test') && lowerText.includes('test')) return btn.dataset.id;
        if (displayName.includes('date') && /\d{1,2}\/\d{1,2}\/\d{2,4}/.test(text)) return btn.dataset.id;
        if (displayName.includes('number') && /^\d+/.test(text)) return btn.dataset.id;
        if (displayName.includes('entity') || displayName.includes('nom')) return btn.dataset.id;
    }

    // Default: return first available type
    return buttons[0]?.dataset.id || null;
}

async function editAnnotationVisual(annotationId) {
    // Check if annotation exists in structured content
    const structuredAnn = document.querySelector(`.inline-annotation[data-annotation-id="${annotationId}"]`);
    if (!structuredAnn) {
        alert('? Cette annotation n\'existe pas dans le document. Utilisez "Restaurer" d\'abord.');
        return;
    }

    const card = document.querySelector(`.annotation-card[data-annotation-id="${annotationId}"]`);
    if (!card) {
        console.error('Card not found for annotation:', annotationId);
        return;
    }

    const textDisplay = card.querySelector('.annotation-text-display');
    if (!textDisplay) {
        console.error('Text display not found in card');
        alert(' Erreur: impossible de trouver le texte de l\'annotation');
        return;
    }

    // Get current text WITHOUT quotes
    const currentText = textDisplay.textContent.replace(/^"|"$/g, '').trim();

    // CRITICAL: Store the FULL original text from structured content
    const fullOriginalText = structuredAnn.getAttribute('data-original-text') || currentText;

    const newText = prompt('? Modifier le texte annot&eacute;:\n(Le reste du texte restera visible sans surlignage)', currentText);
    if (!newText) return; // User cancelled

    // Remove quotes if user added them
    const cleanNewText = newText.replace(/^"|"$/g, '').trim();

    if (cleanNewText === currentText) return; // No change

    // Show loading
    card.style.opacity = '0.5';
    card.style.pointerEvents = 'none';

    // Get type ID
    const badge = card.querySelector('.annotation-type-badge');
    if (!badge) {
        alert(' Badge de type introuvable');
        card.style.opacity = '1';
        card.style.pointerEvents = 'auto';
        return;
    }

    const typeDisplay = badge.textContent.trim();
    const color = badge.style.color || '#ffeb3b';

    const rawTypeId = sanitizeTypeId(structuredAnn.dataset.annotationTypeId) ||
        sanitizeTypeId(card.dataset.annotationTypeId) ||
        sanitizeTypeId(badge.dataset.annotationTypeId);
    let typeId = rawTypeId || null;

    if (!typeId) {
        try {
            const detailsResp = await fetch(`/annotation/${annotationId}/details/`, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                }
            });

            if (detailsResp.ok) {
                const detailsData = await detailsResp.json();
                const resolvedId = sanitizeTypeId(detailsData?.annotation?.annotation_type?.id || detailsData?.annotation?.annotation_type_id);
                if (detailsData.success && resolvedId) {
                    typeId = resolvedId;
                    structuredAnn.dataset.annotationTypeId = String(typeId);
                    card.dataset.annotationTypeId = String(typeId);
                    badge.dataset.annotationTypeId = String(typeId);
                }
            }
        } catch (err) {
            console.warn('? Unable to fetch annotation details for type fallback:', err);
        }
    }

    if (!typeId) {
        typeId = sanitizeTypeId(getTypeIdFromDisplay(typeDisplay, { allowFallback: false }));
    }

    if (!typeId) {
        console.warn(`? Missing type ID for annotation ${annotationId}; backend will preserve the existing type.`);
    }

    console.log(' Editing annotation:', annotationId);
    console.log('   Full original text:', fullOriginalText);
    console.log('   New highlighted part:', cleanNewText);

    // Update in database
    const payload = {
        selected_text: cleanNewText,
        start_pos: 0,
        end_pos: cleanNewText.length
    };

    if (typeId) {
        payload.annotation_type_id = /^\d+$/.test(String(typeId)) ? parseInt(typeId, 10) : typeId;
    }

    fetch(`/annotation/${annotationId}/edit/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update card UI (without quotes in display)
            textDisplay.textContent = `"${cleanNewText}"`;
            card.style.opacity = '1';
            card.style.pointerEvents = 'auto';

            if (typeId) {
                const typeIdString = String(typeId);
                card.dataset.annotationTypeId = typeIdString;
                if (badge) {
                    badge.dataset.annotationTypeId = typeIdString;
                }
                if (structuredAnn) {
                    structuredAnn.dataset.annotationTypeId = typeIdString;
                }
            }

            setTimeout(() => {
                loadAnnotationsInStructuredContent();
                loadVisualAnnotations();
            }, 200);

            return;

            // CRITICAL: Update in structured content while preserving full text
            const labelElement = structuredAnn.querySelector('.ann-label');
            const labelText = labelElement ? labelElement.textContent : typeDisplay;

            // Calculate what text should remain unhighlighted
            let remainingText = '';
            if (fullOriginalText.includes(cleanNewText)) {
                // If new text is a subset of original
                const startIndex = fullOriginalText.indexOf(cleanNewText);
                const beforePart = fullOriginalText.substring(0, startIndex);
                const afterPart = fullOriginalText.substring(startIndex + cleanNewText.length);
                remainingText = beforePart + afterPart;
            } else if (cleanNewText.includes(fullOriginalText)) {
                // If new text is longer (user added more)
                remainingText = cleanNewText.replace(fullOriginalText, '');
            } else {
                // Text was completely changed
                remainingText = fullOriginalText.replace(cleanNewText, '');
            }

            console.log('   Remaining unhighlighted text:', remainingText);

            // Remove old annotation span completely
            const parent = structuredAnn.parentNode;
            const beforeNode = structuredAnn.previousSibling;
            const afterNode = structuredAnn.nextSibling;

            // Create new structure: [remaining text before] + [highlighted new text] + [remaining text after]
            const fragment = document.createDocumentFragment();

            // Determine where the remaining text should go
            if (fullOriginalText.startsWith(cleanNewText)) {
                // New text is at the beginning, remaining goes after
                // [highlighted: cleanNewText] + [plain: remainingText]

                const newSpan = document.createElement('span');
                newSpan.className = 'inline-annotation';
                newSpan.dataset.annotationId = annotationId;

                // CRITICAL FIX: Convert color to rgba properly
                const rgb = hexToRgb(color);
                const bgColor = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `${color}33`;

                newSpan.style.cssText = `
                    background-color: ${bgColor};
                    color: inherit;
                    font-family: inherit;
                    font-size: inherit;
                    font-weight: inherit;
                    padding: 2px 4px;
                    margin: 0 1px;
                    border-radius: 3px;
                    cursor: pointer;
                `;
                newSpan.textContent = cleanNewText;
                newSpan.setAttribute('data-original-text', fullOriginalText);

                const newLabel = document.createElement('span');
                newLabel.className = 'ann-label';
                newLabel.style.cssText = `
                    font-size: 0.7rem;
                    font-weight: bold;
                    margin-left: 4px;
                    padding: 2px 6px;
                    border-radius: 4px;
                    background: rgba(0,0,0,0.6);
                    color: #fff;
                    white-space: nowrap;
                    display: inline;
                    opacity: 1;
                `;
                newLabel.textContent = labelText;
                newSpan.appendChild(newLabel);

                // Add click handler
                newSpan.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const fullText = this.getAttribute('data-original-text');
                    if (fullText) {
                        const textNode = document.createTextNode(fullText);
                        this.parentNode.replaceChild(textNode, this);
                    }
                    deleteAnnotationAndUpdateJSON(annotationId);
                });

                fragment.appendChild(newSpan);
                if (remainingText) {
                    fragment.appendChild(document.createTextNode(remainingText));
                }

            } else if (fullOriginalText.endsWith(cleanNewText)) {
                // New text is at the end, remaining goes before
                // [plain: remainingText] + [highlighted: cleanNewText]

                if (remainingText) {
                    fragment.appendChild(document.createTextNode(remainingText));
                }

                const newSpan = document.createElement('span');
                newSpan.className = 'inline-annotation';
                newSpan.dataset.annotationId = annotationId;

                // CRITICAL FIX: Convert color to rgba properly
                const rgb = hexToRgb(color);
                const bgColor = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `${color}33`;

                newSpan.style.cssText = `
                    background-color: ${bgColor};
                    color: inherit;
                    font-family: inherit;
                    font-size: inherit;
                    font-weight: inherit;
                    padding: 2px 4px;
                    margin: 0 1px;
                    border-radius: 3px;
                    cursor: pointer;
                `;
                newSpan.textContent = cleanNewText;
                newSpan.setAttribute('data-original-text', fullOriginalText);

                const newLabel = document.createElement('span');
                newLabel.className = 'ann-label';
                newLabel.style.cssText = `
                    font-size: 0.7rem;
                    font-weight: bold;
                    margin-left: 4px;
                    padding: 2px 6px;
                    border-radius: 4px;
                    background: rgba(0,0,0,0.6);
                    color: #fff;
                    white-space: nowrap;
                    display: inline;
                    opacity: 1;
                `;
                newLabel.textContent = labelText;
                newSpan.appendChild(newLabel);

                newSpan.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const fullText = this.getAttribute('data-original-text');
                    if (fullText) {
                        const textNode = document.createTextNode(fullText);
                        this.parentNode.replaceChild(textNode, this);
                    }
                    deleteAnnotationAndUpdateJSON(annotationId);
                });

                fragment.appendChild(newSpan);

            } else {
                // New text is in the middle or completely different
                const startIndex = fullOriginalText.indexOf(cleanNewText);

                if (startIndex !== -1) {
                    // Found in middle
                    const before = fullOriginalText.substring(0, startIndex);
                    const after = fullOriginalText.substring(startIndex + cleanNewText.length);

                    if (before) fragment.appendChild(document.createTextNode(before));

                    const newSpan = document.createElement('span');
                    newSpan.className = 'inline-annotation';
                    newSpan.dataset.annotationId = annotationId;

                    // CRITICAL FIX: Convert color to rgba properly
                    const rgb = hexToRgb(color);
                    const bgColor = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `${color}33`;

                    newSpan.style.cssText = `
                        background-color: ${bgColor};
                        color: inherit;
                        font-family: inherit;
                        font-size: inherit;
                        font-weight: inherit;
                        padding: 2px 4px;
                        margin: 0 1px;
                        border-radius: 3px;
                        cursor: pointer;
                    `;
                    newSpan.textContent = cleanNewText;
                    newSpan.setAttribute('data-original-text', fullOriginalText);

                    const newLabel = document.createElement('span');
                    newLabel.className = 'ann-label';
                    newLabel.style.cssText = `
                        font-size: 0.7rem;
                        font-weight: bold;
                        margin-left: 4px;
                        padding: 2px 6px;
                        border-radius: 4px;
                        background: rgba(0,0,0,0.6);
                        color: #fff;
                        white-space: nowrap;
                        display: inline;
                        opacity: 1;
                    `;
                    newLabel.textContent = labelText;
                    newSpan.appendChild(newLabel);

                    newSpan.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const fullText = this.getAttribute('data-original-text');
                        if (fullText) {
                            const textNode = document.createTextNode(fullText);
                            this.parentNode.replaceChild(textNode, this);
                        }
                        deleteAnnotationAndUpdateJSON(annotationId);
                    });

                    fragment.appendChild(newSpan);
                    if (after) fragment.appendChild(document.createTextNode(after));

                } else {
                    // Completely different text - just highlight new, keep old as plain
                    fragment.appendChild(document.createTextNode(fullOriginalText));
                }
            }

            // Replace old annotation with new structure
            parent.replaceChild(fragment, structuredAnn);

            console.log(' Annotation updated with text preservation');

            // Reload to confirm
            setTimeout(() => {
                loadVisualAnnotations();
            }, 500);
        } else {
            alert(' Erreur: ' + data.error);
            card.style.opacity = '1';
            card.style.pointerEvents = 'auto';
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert(' Erreur r&eacute;seau: ' + error.message);
        card.style.opacity = '1';
        card.style.pointerEvents = 'auto';
    });
}


function updateExpertJSON() {
    console.log(' Updating expert JSON in real-time...');

    // Force reload from server to ensure we have latest data
    if (currentJSONTab === 'page') {
        const pageId = document.getElementById('structured-annotation-area')?.dataset.pageId;
        if (pageId) {
            loadPageJSON(pageId);
        }
    } else {
        // For document JSON, trigger regeneration
        const docId = {{ document.id }};
        fetch(`/annotation/document/${docId}/generate-summary/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.global_json) {
                displayJSON('document-json-display', data.global_json);
                document.getElementById('doc-total-annotations').textContent = data.stats.total_annotations;
            }
        });
    }

    showSyncIndicator();
}

function loadPageJSON(pageId) {
    fetch(`/annotation/page/${pageId}/`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const json = {
                    page: {
                        number: {{ current_page.page_number }},
                        annotations_count: data.annotations.length
                    },
                    entities: buildEntitiesFromAnnotations(data.annotations),
                    annotations: data.annotations,
                    generated_at: new Date().toISOString()
                };

                // Update visual mode
                displayVisualAnnotations(data.annotations);

                // Update code mode (hidden by default)
                displayJSON('page-json-display', json);

                document.getElementById('page-annotations-count').textContent = data.annotations.length;
            }
        })
        .catch(error => {
            console.error('Error loading page JSON:', error);
            document.getElementById('page-json-display').textContent = 'Erreur de chargement du JSON';
        });
}

function loadDocumentJSON() {
    const docId = {{ document.id }};

    // Try to get global JSON if available
    {% if document.global_annotations_json %}
    const globalJSON = {{ document.global_annotations_json|safe }};
    displayJSON('document-json-display', globalJSON);

    if (globalJSON.document) {
        document.getElementById('doc-total-annotations').textContent = globalJSON.document.total_annotations || 0;
        document.getElementById('doc-total-pages').textContent = globalJSON.document.total_pages || {{ document.total_pages }};
    }
    {% else %}
    // Fallback: Build JSON from current state
    fetch(`/annotation/document/${docId}/generate-summary/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.global_json) {
            displayJSON('document-json-display', data.global_json);
            document.getElementById('doc-total-annotations').textContent = data.stats.total_annotations;
        }
    })
    .catch(error => {
        console.error('Error loading document JSON:', error);
        document.getElementById('document-json-display').textContent = 'Erreur de chargement du JSON';
    });
    {% endif %}
}

function buildEntitiesFromAnnotations(annotations) {
    const entities = {};

    annotations.forEach(ann => {
        const type = ann.type_display;
        if (!entities[type]) {
            entities[type] = [];
        }
        if (!entities[type].includes(ann.selected_text)) {
            entities[type].push(ann.selected_text);
        }
    });

    return entities;
}

function displayJSON(elementId, jsonData) {
    const element = document.getElementById(elementId);
    if (!element) return;

    const formatted = JSON.stringify(jsonData, null, 2);
    const highlighted = syntaxHighlight(formatted);
    element.innerHTML = highlighted;

    makeJSONEditable(elementId);
}


function makeJSONEditable(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return;

    element.contentEditable = 'true';
    element.style.outline = '1px dashed rgba(59,130,246,0.3)';

    let saveTimeout;
    element.addEventListener('input', function() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            processJSONChanges(elementId);
        }, 1000); // Wait 1s after typing stops
    });
}

function processJSONChanges(elementId) {
    const element = document.getElementById(elementId);
    const rawText = element.textContent;

    try {
        const newJSON = JSON.parse(rawText);
        console.log(' JSON edited, syncing to structured content...');

        // CRITICAL: Prevent infinite loops - disable observer temporarily
        if (window.jsonSyncObserver) {
            window.jsonSyncObserver.disconnect();
        }

        // Get current annotations from structured content
        const structuredArea = document.getElementById('structured-annotation-area');
        if (!structuredArea) {
            console.error('Structured area not found');
            return;
        }

        const currentAnnotations = Array.from(structuredArea.querySelectorAll('.inline-annotation'));

        if (elementId === 'page-json-display' && newJSON.annotations) {
            syncJSONToStructuredContent(newJSON.annotations, currentAnnotations);
        } else if (elementId === 'document-json-display' && newJSON.pages) {
            const currentPageNum = {{ current_page.page_number }};
            const currentPageData = newJSON.pages.find(p => p.page_number === currentPageNum);
            if (currentPageData && currentPageData.annotations) {
                syncJSONToStructuredContent(currentPageData.annotations, currentAnnotations);
            }
        }

        element.style.borderColor = '#10b981';
        setTimeout(() => {
            element.style.borderColor = '';
            // Re-enable observer after sync completes
            if (window.jsonSyncObserver) {
                setTimeout(() => {
                    setupRealtimeSync();
                }, 1000);
            }
        }, 500);

    } catch (e) {
        console.error('Invalid JSON:', e);
        element.style.borderColor = '#ef4444';
        alert(' JSON invalide: ' + e.message);
        setTimeout(() => element.style.borderColor = '', 1000);
    }
}


function syncJSONToStructuredContent(jsonAnnotations, currentAnnotations) {
    const structuredArea = document.getElementById('structured-annotation-area');
    if (!structuredArea) return;

    console.log(' Starting sync:', jsonAnnotations.length, 'JSON annotations vs', currentAnnotations.length, 'current');

    // Build maps for comparison
    const jsonMap = new Map();
    jsonAnnotations.forEach(ann => {
        const normalizedAnn = {
            id: ann.id,
            selected_text: ann.selected_text || ann.text,
            type_display: ann.type_display || ann.type,
            color: ann.color || '#ffeb3b',
            annotation_type: {
                id: ann.annotation_type?.id || getTypeIdFromDisplay(ann.type_display || ann.type) || inferAnnotationType(ann.selected_text || ann.text),
                name: ann.type || 'default',
                display_name: ann.type_display || ann.type || 'Entity'
            }
        };

        // Only add if we have a valid type ID
        if (normalizedAnn.annotation_type.id) {
            jsonMap.set(ann.id, normalizedAnn);
        } else {
            console.warn('? Skipping annotation without valid type:', ann);
        }
    });

    const currentMap = new Map();
    currentAnnotations.forEach(ann => {
        const id = parseInt(ann.dataset.annotationId);
        if (!isNaN(id) && !String(ann.dataset.annotationId).startsWith('temp-')) {
            currentMap.set(id, ann);
        }
    });

    // 1. DELETIONS: Remove annotations not in JSON
    currentMap.forEach((annElement, id) => {
        if (!jsonMap.has(id)) {
            console.log('? Deleting annotation', id);
            const originalText = annElement.getAttribute('data-original-text') || annElement.textContent.replace(/\[.*?\]/, '');
            const textNode = document.createTextNode(originalText);
            annElement.parentNode.replaceChild(textNode, annElement);

            // Delete from DB without triggering refresh
            fetch(`/annotation/${id}/delete/`, {
                method: 'POST',
                headers: { 'X-CSRFToken': getCookie('csrftoken') }
            }).then(r => r.json()).then(d => {
                if (d.success) console.log(' Deleted from DB:', id);
            });
        }
    });

    // 2. MODIFICATIONS: Update changed annotations
    jsonMap.forEach((jsonAnn, id) => {
        const existingElement = currentMap.get(id);
        if (existingElement) {
            const currentText = existingElement.getAttribute('data-original-text') ||
                              existingElement.textContent.replace(/\[.*?\]/, '');

            if (currentText !== jsonAnn.selected_text) {
                console.log('? Modifying annotation', id);

                // Remove old
                const oldText = existingElement.getAttribute('data-original-text') || existingElement.textContent.replace(/\[.*?\]/, '');
                const textNode = document.createTextNode(oldText);
                existingElement.parentNode.replaceChild(textNode, existingElement);

                // Add new
                addAnnotationToStructuredContent({
                    id: id,
                    selected_text: jsonAnn.selected_text,
                    type_display: jsonAnn.type_display,
                    color: jsonAnn.color
                });

                // Update DB
                fetch(`/annotation/${id}/edit/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken'),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        selected_text: jsonAnn.selected_text,
                        annotation_type_id: jsonAnn.annotation_type.id
                    })
                });
            }
        }
    });

    // 3. ADDITIONS: Add new annotations from JSON
    jsonMap.forEach((jsonAnn, id) => {
        if (!currentMap.has(id) && !String(id).startsWith('temp-')) {
            console.log(' Adding new annotation:', (jsonAnn.selected_text || jsonAnn.text || '').substring(0, 30));

            addAnnotationToStructuredContent(jsonAnn);

            // Save to DB
            fetch("{% url 'rawdocs:save_manual_annotation' %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    page_id: structuredArea.dataset.pageId,
                    type_id: jsonAnn.annotation_type.id,
                    selected_text: jsonAnn.selected_text,
                    start_pos: 0,
                    end_pos: jsonAnn.selected_text.length,
                    mode: 'structured'
                })
            });
        }
    });

    console.log(' Sync complete');
}

function setupRealtimeSync() {
    const leftArea = document.getElementById('structured-annotation-area');
    if (!leftArea) return;

    // DISABLED: This was causing too many issues with JSON editing
    // We'll rely on manual refresh instead
    console.log('? Real-time sync disabled to prevent conflicts');

    // Optional: Add a manual refresh button instead
    const refreshBtn = document.createElement('button');
    refreshBtn.innerHTML = '<i class="fas fa-sync"></i>';
    refreshBtn.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #10b981; color: white; border: none; padding: 12px; border-radius: 50%; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 9999;';
    refreshBtn.title = 'Rafra&icirc;chir le JSON';
    refreshBtn.onclick = function() {
        loadVisualAnnotations();
        this.style.transform = 'rotate(360deg)';
        setTimeout(() => this.style.transform = '', 500);
    };
    document.body.appendChild(refreshBtn);
}

function syntaxHighlight(json) {
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
        let cls = 'json-number';
        if (/^"/.test(match)) {
            if (/:$/.test(match)) {
                cls = 'json-key';
            } else {
                cls = 'json-string';
            }
        } else if (/true|false/.test(match)) {
            cls = 'json-boolean';
        } else if (/null/.test(match)) {
            cls = 'json-null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
    });
}

function switchJSONTab(tab) {
    currentJSONTab = tab;

    // Update tab buttons
    document.querySelectorAll('.json-tab-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'rgba(255,255,255,0.1)';
        btn.style.color = 'rgba(255,255,255,0.6)';
    });

    if (tab === 'page') {
        document.getElementById('page-json-tab').classList.add('active');
        document.getElementById('page-json-content').style.display = 'block';
        document.getElementById('document-json-content').style.display = 'none';
    } else {
        document.getElementById('document-json-tab').classList.add('active');
        document.getElementById('page-json-content').style.display = 'none';
        document.getElementById('document-json-content').style.display = 'block';
    }
}

function refreshExpertJSON() {
    updateExpertJSON();
    showSyncIndicator();
}

function copyJSONToClipboard() {
    const jsonElement = currentJSONTab === 'page' ?
        document.getElementById('page-json-display') :
        document.getElementById('document-json-display');

    const jsonText = jsonElement.textContent;

    navigator.clipboard.writeText(jsonText).then(() => {
        alert(' JSON copi&eacute; dans le presse-papier !');
    }).catch(err => {
        console.error('Erreur copie:', err);
    });
}

function showSyncIndicator() {
    const indicator = document.getElementById('sync-indicator');
    if (!indicator) return;
    indicator.classList.add('active');
    setTimeout(() => indicator.classList.remove('active'), 1500);
}

function toggleRightPanel() {
    const panel = document.getElementById('right-panel-body');
    const btn = event.currentTarget;
    const icon = btn.querySelector('i');
    const text = btn.querySelector('span');

    if (panel.style.display === 'none') {
        panel.style.display = 'block';
        icon.className = 'fas fa-eye-slash';
        text.textContent = 'Masquer';
    } else {
        panel.style.display = 'none';
        icon.className = 'fas fa-eye';
        text.textContent = 'Afficher';
    }
}
</script>
<script>
// Show only the current page in structured content
document.addEventListener('DOMContentLoaded', function() {
    const currentPageNumber = {{ current_page.page_number }};
    const allPagesContent = document.getElementById('all-pages-content');

    if (allPagesContent) {
        // Find all page elements (adjust selector based on your HTML structure)
        const allPages = allPagesContent.querySelectorAll('[class*="page"], [id*="page"], section, .page-content');

        console.log(`Found ${allPages.length} page elements`);

        if (allPages.length > 0) {
            // Hide all pages
            allPages.forEach((page, index) => {
                page.style.display = 'none';
            });

            // Show only current page (0-indexed, so subtract 1)
            const currentPageElement = allPages[currentPageNumber - 1];
            if (currentPageElement) {
                currentPageElement.style.display = 'block';
                console.log(`Showing page ${currentPageNumber}`);
            } else {
                console.warn(`Page ${currentPageNumber} not found, showing first page`);
                allPages[0].style.display = 'block';
            }
        } else {
            console.log('No page structure found, showing all content');
        }
    }
});

</script>
{% endblock %}
